<!DOCTYPE html>
<html lang="zh-CN">
    
    <head>
    <meta charset="utf-8">
    <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover" name="viewport" />
    <meta name="description" content="前端面试题总结" />
    <meta name="hexo-theme-A4" content="v1.9.0" />
    <link rel="alternate icon" type="image/webp" href="/img/favicon.webp">
    <title>Andrew&#39;s Home</title>

    
        
<link rel="stylesheet" href="/css/highlight/style1.css">

        
<link rel="stylesheet" href="/css/reset.css">

        
<link rel="stylesheet" href="/css/markdown.css">

        
<link rel="stylesheet" href="/css/fonts.css">
 
         <!--注意：首页既不是post也不是page-->
        
        
        
<link rel="stylesheet" href="/css/ui.css">
 
        
<link rel="stylesheet" href="/css/style.css">


        
            <!--返回顶部css-->
            
<link rel="stylesheet" href="/css/returnToTop.css">

            
<link rel="stylesheet" href="/css/unicons.css">

        
        
            <!--目录-->
            
<link rel="stylesheet" href="/css/toc.css">

        
    

    
        
<link rel="stylesheet" href="/css/returnToLastPage.css">

    
    
   
<link rel="stylesheet" href="/css/lightgallery.min.css">


<meta name="generator" content="Hexo 7.1.1"></head>
    
    
    
    <body>
        <script src="/js/darkmode-js.min.js"></script>
        
        <script>
            const dkOptions = {
                bottom: '53px', // default: '32px'
                right: 'unset', // default: '32px'
                left: '42px', // default: 'unset'
                time: '0.3s', // default: '0.3s'
                mixColor: '#fff', // default: '#fff'
                backgroundColor: ' #e4e4e4 ',  // default: '#fff'
                buttonColorDark: '#100f2c',  // default: '#100f2c'
                buttonColorLight: '#fff', // default: '#fff'
                saveInCookies: true, // default: true,
                label: '🌓', // default: ''
                autoMatchOsTheme: true // default: true
            }
            const darkmode = new Darkmode(dkOptions);
            darkmode.showWidget();
        </script>
        
        
            <div class="left-toc-container">
                <nav id="toc" class="bs-docs-sidebar"></nav>
            </div>
        
        <div class="paper">
            
            
            
            
                <div class="shadow-drop-2-bottom paper-main">
                    


<div class="header">
    <div class="header-container">
        <img style="
        width: 56px;
        height: auto;border-radius: 6px;" alt="^-^" cache-control="max-age=86400" class="header-img" src="/img/favicon.webp" width="10%"></img>
        <div class="header-content">
            <a class="logo" href="/">Andrew</a> 
            <span class="description"></span> 
        </div>
        
    </div>
    
   
    <ul class="nav">
        
            
                <li><a href="/">首页</a></li>
            
        
            
                <li><a href="/list/">文章</a></li>
            
        
            
                <li><a href="/categories/">分类</a></li>
            
        
            
                <li><a href="/project/">作品</a></li>
            
        
            
                <li><a href="/annual/">年度</a></li>
            
        
            
                <li><a href="/masonry/">相册</a></li>
            
        
            
                <li><a href="/message/">留言</a></li>
            
        
            
                <li><a href="/about/">关于</a></li>
            
        
    </ul>
</div> 
        
                    
                    

                    
                    
                    
                    <!--说明是文章post页面-->
                    
                        <div class="post-main">

    
        <div class="post-main-title">
            前端面试题总结
        </div>
      
    

    <div class="post-md">
        
            
                <ol class="post-toc"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93"><span class="post-toc-text">前端面试题总结</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="post-toc-text">数据类型</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B"><span class="post-toc-text">基本类型</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B"><span class="post-toc-text">引用类型</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E7%B1%BB%E5%9E%8B%E5%88%A4%E6%96%AD"><span class="post-toc-text">类型判断</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E6%95%B0%E7%BB%84-%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="post-toc-text">数组&#x2F;字符串</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E6%95%B0%E7%BB%84%E6%93%8D%E4%BD%9C%E6%96%B9%E6%B3%95"><span class="post-toc-text">数组操作方法</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%93%8D%E4%BD%9C%E6%96%B9%E6%B3%95"><span class="post-toc-text">字符串操作方法</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Map-Set"><span class="post-toc-text">Map &amp; Set</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E5%87%BD%E6%95%B0"><span class="post-toc-text">函数</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E6%99%AE%E9%80%9A%E5%87%BD%E6%95%B0"><span class="post-toc-text">普通函数</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#function%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="post-toc-text">function构造函数</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#class%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0-%E6%9C%AC%E8%B4%A8%E4%BB%8D%E7%84%B6%E6%98%AFfunction%E7%9A%84%E8%AF%AD%E6%B3%95%E7%B3%96"><span class="post-toc-text">class构造函数(本质仍然是function的语法糖)</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#bind-%E5%92%8Ccall-%E4%B8%8Eapply-%E5%8C%BA%E5%88%AB"><span class="post-toc-text">bind()和call()与apply()区别:</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8API"><span class="post-toc-text">浏览器API</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#ajax%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E5%92%8C%E4%BD%BF%E7%94%A8"><span class="post-toc-text">ajax如何创建和使用</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8%E4%B8%8ECookie%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="post-toc-text">本地存储与Cookie的区别</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#Json%E5%A6%82%E4%BD%95%E6%96%B0%E5%A2%9E-%E5%88%A0%E9%99%A4%E9%94%AE%E5%80%BC%E5%AF%B9"><span class="post-toc-text">Json如何新增&#x2F;删除键值对</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#ES6%E6%96%B0%E7%89%B9%E6%80%A7"><span class="post-toc-text">ES6新特性</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5"><span class="post-toc-text">核心概念</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E9%97%AD%E5%8C%85"><span class="post-toc-text">闭包</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2"><span class="post-toc-text">什么是内存泄露?</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E5%8E%9F%E5%9E%8B-%E5%8E%9F%E5%9E%8B%E9%93%BE-%E7%BB%A7%E6%89%BF"><span class="post-toc-text">原型&#x2F;原型链&#x2F;继承</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E5%90%8C%E6%AD%A5%E4%B8%8E%E5%BC%82%E6%AD%A5%E7%9A%84%E5%8C%BA%E5%88%AB-%E9%98%BB%E5%A1%9E%E4%B8%8E%E9%9D%9E%E9%98%BB%E5%A1%9E%E5%8C%BA%E5%88%AB"><span class="post-toc-text">同步与异步的区别&#x2F;阻塞与非阻塞区别</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E8%AF%B7%E7%AE%80%E8%BF%B0async%E7%9A%84%E7%94%A8%E6%B3%95"><span class="post-toc-text">请简述async的用法</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFJSONP%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88"><span class="post-toc-text">什么是JSONP工作原理是什么?</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98%E6%98%AF%E4%BB%80%E4%B9%88-%E5%A6%82%E4%BD%95%E7%A1%AE%E5%AE%9A%E4%BA%8B%E4%BB%B6%E6%BA%90"><span class="post-toc-text">事件委托是什么?如何确定事件源</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#This%E6%8C%87%E5%90%91"><span class="post-toc-text">This指向</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E4%B8%8E%E6%99%AE%E9%80%9A%E5%87%BD%E6%95%B0%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="post-toc-text">箭头函数与普通函数的区别</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E6%99%AE%E9%80%9A%E5%87%BD%E6%95%B0%E5%92%8C%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="post-toc-text">普通函数和构造函数的区别</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AF%B7%E7%AE%80%E8%BF%B0"><span class="post-toc-text">什么是面向对象请简述</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E9%87%8D%E7%BB%98%E4%BB%A5%E5%8F%8A%E5%9B%9E%E6%B5%81%E6%98%AF%E4%BB%80%E4%B9%88"><span class="post-toc-text">重绘以及回流是什么</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF-Event-Loop"><span class="post-toc-text">事件循环(Event Loop)</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D"><span class="post-toc-text">深浅拷贝</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#Promise"><span class="post-toc-text">Promise</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E5%87%BD%E6%95%B0%E8%8A%82%E6%B5%81%E5%92%8C%E5%87%BD%E6%95%B0%E9%98%B2%E6%8A%96-%E4%BC%98%E5%8C%96%E9%AB%98%E9%A2%91%E7%8E%87%E6%89%A7%E8%A1%8Cjs%E4%BB%A3%E7%A0%81%E7%9A%84%E4%B8%80%E7%A7%8D%E6%89%8B%E6%AE%B5"><span class="post-toc-text">函数节流和函数防抖(优化高频率执行js代码的一种手段)</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#VUE"><span class="post-toc-text">VUE</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#VUE2"><span class="post-toc-text">VUE2</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#VUE3"><span class="post-toc-text">VUE3</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#TypeScript"><span class="post-toc-text">TypeScript</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#Typescript%E6%98%AF%E4%BB%80%E4%B9%88-%E8%AF%B7%E7%AE%80%E8%BF%B0"><span class="post-toc-text">Typescript是什么 请简述?</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#Typescript-%E4%B8%8Ejavascript-%E7%9A%84%E4%BC%98%E5%8A%BF"><span class="post-toc-text">Typescript 与javascript 的优势?</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E5%B7%A5%E7%A8%8B%E5%8C%96%E5%B7%A5%E5%85%B7"><span class="post-toc-text">工程化工具</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#Webpack"><span class="post-toc-text">Webpack</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#rollup"><span class="post-toc-text">rollup</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#babelrc"><span class="post-toc-text">babelrc</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#eslint"><span class="post-toc-text">eslint</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E7%BD%91%E7%BB%9C"><span class="post-toc-text">网络</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#Get%E5%92%8Cpost%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="post-toc-text">Get和post有什么区别？</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84HTTP%E7%8A%B6%E6%80%81%E7%A0%81"><span class="post-toc-text">常见的HTTP状态码:</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#http%E6%98%AF%E4%BB%80%E4%B9%88-%E6%9C%89%E4%BB%80%E4%B9%88%E7%89%B9%E7%82%B9"><span class="post-toc-text">http是什么?有什么特点</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#HTTP%E5%8D%8F%E8%AE%AE%E5%92%8CHTTPS%E5%8C%BA%E5%88%AB"><span class="post-toc-text">HTTP协议和HTTPS区别</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFcsrf%E6%94%BB%E5%87%BB"><span class="post-toc-text">什么是csrf攻击</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E9%80%A0%E6%88%90%E8%B7%A8%E5%9F%9F-%E8%AF%B7%E7%AE%80%E8%BF%B0%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5"><span class="post-toc-text">为什么会造成跨域&#x2F;请简述同源策略</span></a></li></ol></li></ol></li></ol>
            
        
        <link rel="stylesheet" type="text/css" href="https://jsd.onmicrosoft.cn/npm/hexo-theme-a4@latest/source/css/lightgallery.min.css" /><div class=".article-gallery"><h2 id="前端面试题总结"><a href="#前端面试题总结" class="headerlink" title="前端面试题总结"></a>前端面试题总结</h2><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><h4 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h4><ul>
<li>string ‘字符串’</li>
<li>number ‘64位双精度浮点型数字’(包含NaN)</li>
<li>boolean ‘布尔’,</li>
<li>undefined ‘没有任何值’</li>
<li>null ‘没有任何对象’</li>
<li>bigint ‘任意精度格式的整数’</li>
<li>symbol ‘标记值’</li>
</ul>
<h4 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h4><ul>
<li>对象’object’(Function也是一个特殊的对象)</li>
</ul>
<h4 id="类型判断"><a href="#类型判断" class="headerlink" title="类型判断"></a>类型判断</h4><ul>
<li>如何判断一个数据是NaN<ul>
<li>用全等判断 x &#x3D;&#x3D;&#x3D; NaN;</li>
<li>用isNaN(x) 来判断;</li>
</ul>
</li>
<li>null与undefined区别<ul>
<li>null 表示一个值被定义了,定义为“空值”;</li>
<li>undefined 表示根本不存在定义;</li>
</ul>
</li>
<li>typeof和istanceof区别?<ul>
<li>typeof 会返回一个运算数的基本类型</li>
<li>instanceof 判断一个对象是否是某个构造函数的实例<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;&#125;</span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p <span class="keyword">instanceof</span> <span class="title class_">Person</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>如何判断一个对象是对象<ul>
<li>Object.prototype.toString.call({}) &#x2F;&#x2F; “[object Object]”</li>
</ul>
</li>
<li>如何判断一个对象时数组<ul>
<li>Object.prototype.toString.call([]) &#x2F;&#x2F; “[object Array]”</li>
<li>Array.isArray([])</li>
<li>[] instanceof Array &#x2F;&#x2F; true</li>
</ul>
</li>
</ul>
<h3 id="数组-字符串"><a href="#数组-字符串" class="headerlink" title="数组&#x2F;字符串"></a>数组&#x2F;字符串</h3><h4 id="数组操作方法"><a href="#数组操作方法" class="headerlink" title="数组操作方法"></a>数组操作方法</h4><ul>
<li>arr.push() 从后添,返回值为添加完后的数组的长度</li>
<li>arr.pop() 从后删一个,返回值是删除的元素</li>
<li>arr.unshift() 从前添,返回值是添加后数组的长度</li>
<li>arr.shift() 从前删一个,返回值是删除的元素</li>
<li>arr.splice(i,n)从数组中添加&#x2F;删除&#x2F;修改值,返回值被改动的值</li>
<li>arr.concat() 连接两个数组 返回值为连接后的新数组</li>
<li>arr.sort() 将数组进行排序,返回值是排好的数组,默认是按照最左边的数字进行排序,不是按照数字大小排序的</li>
<li>arr.reverse() 将数组反转,返回值是反转后的数组</li>
<li>arr.slice(start,end) 切一段从索引值start到end(不包含)的数组,返回值是切出来的数组</li>
<li>arr.join(separator)  把数组的所有元素放入一个字符串,方法内的参数作为分隔符,省略该参数,则使用逗号作为分隔符</li>
<li>arr.forEach(callback) 遍历数组,无return  即使有return,也不会返回任何值,并且会影响原来的数组</li>
<li>arr.map(callback) 映射数组(遍历数组),有return 返回一个新数组</li>
<li>arr.filter(callback) 过滤数组,返回一个满足要求的数组 </li>
<li>arr.indxOf() : 返回数组中满足提供的测试函数的第一个元素的下标</li>
<li>arr.lastIndexOf() : 从后往前返回数组中满足提供的测试函数的第一个元素的下标</li>
<li>arr.find() : 返回数组中满足提供的测试函数的第一个元素的值</li>
<li>arr.some()  : 测试数组中是否至少有一个元素通过了由提供的函数实现的测试( 一个直则真 )</li>
<li>arr.every() : 测试一个数组内的所有元素是否都能通过指定函数的测试( 全真才真 )</li>
<li>map,forEach和for循环区别:<ul>
<li>forEach只是进行简单的数组遍历,无返回值,且break和return语句不能跳出循环,for可以适用于更复杂的循环且效率更高</li>
<li>map代表是映射它有返回值,返回值是一个处理过后的新数组且不改变原数组</li>
</ul>
</li>
</ul>
<h4 id="字符串操作方法"><a href="#字符串操作方法" class="headerlink" title="字符串操作方法"></a>字符串操作方法</h4><ul>
<li>str.charAt(index)	返回在指定位置的字符</li>
<li>str.concat(stringA,stringB,…,stringZ) 连接两个或多个字符串,返回连接后的字符串</li>
<li>str.indexOf(检索的字符串,开始检索的位置【可省略】)检索字符串返回某个指定的字符串值在字符串中首次出现的位置,如果没有返回-1</li>
<li>str.lastIndexOf(检索的字符串,开始检索的位置【可省略】) 从后向前搜索字符串,返回一个指定的字符串值最后出现的位置,如果没有返-1</li>
<li>str.replace(正则表达式&#x2F;检索的字符串,替换成的字符串)在字符串中用一些字符替换另一些字符,或替换一个与正则表达式匹配的子串.</li>
<li>str.slice(起始下标【slice独有:可为负数,-1指字符串的最后一个字符】,结尾的下标【可省略,如果省略则代表一直到字符串结尾】) 提取字符串的片断,返回被提取的部分.从start开始到end结束(不包括结尾的下标所代表的值)</li>
<li>str.substr(起始下标,长度【可选】) 返回从起始索引号提取字符串中指定数目的字符.</li>
<li>str.substring(起始下标,结束的下标【可选】) 返回提取字符串中两个指定的索引号之间的字符.</li>
<li>str.split(字符串或正则表达式,从该参数指定的地方分割,多少个【可选】) 把字符串分割为字符串数组.</li>
</ul>
<h3 id="Map-Set"><a href="#Map-Set" class="headerlink" title="Map &amp; Set"></a>Map &amp; Set</h3><ul>
<li>概念<ul>
<li>Map:主要用于存储和管理键值对数据,适合在需要快速查找、插入和删除键值对的场景中使用.常见应用包括缓存、配置管理和数据关联.</li>
<li>Set:主要用于存储唯一值集合,适合在需要确保元素不重复的场景中使用.常见应用包括去重、集合操作和存在性检查.</li>
</ul>
</li>
<li>用途<ul>
<li>Map:<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">map.<span class="title function_">set</span>(<span class="string">&#x27;a&#x27;</span>, <span class="number">1</span>); <span class="comment">// 向 Map 添加或更新一个键值对.</span></span><br><span class="line">map.<span class="title function_">set</span>(<span class="string">&#x27;b&#x27;</span>, <span class="number">2</span>);</span><br><span class="line">map.<span class="title function_">set</span>(<span class="string">&#x27;c&#x27;</span>, <span class="number">3</span>); </span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(map.<span class="title function_">get</span>(<span class="string">&#x27;a&#x27;</span>)); <span class="comment">// 获取对应键的值</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(map.<span class="title function_">has</span>(<span class="string">&#x27;b&#x27;</span>)); <span class="comment">// 检查 Map 是否包含某个键.</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(map.<span class="property">size</span>); <span class="comment">// 返回 Map 中的键值对数量.</span></span><br><span class="line"></span><br><span class="line">map.<span class="title function_">delete</span>(<span class="string">&#x27;c&#x27;</span>); <span class="comment">// 删除键值对.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> map) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;key&#125;</span>: <span class="subst">$&#123;value&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br><span class="line">map.<span class="title function_">clear</span>() <span class="comment">//   清空 Map</span></span><br></pre></td></tr></table></figure></li>
<li>Set:<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> set = <span class="keyword">new</span> <span class="title class_">Set</span>();</span><br><span class="line">set.<span class="title function_">add</span>(<span class="number">1</span>); <span class="comment">// 向 Set 添加一个新值</span></span><br><span class="line">set.<span class="title function_">add</span>(<span class="number">2</span>);</span><br><span class="line">set.<span class="title function_">add</span>(<span class="number">3</span>);</span><br><span class="line">set.<span class="title function_">add</span>(<span class="number">1</span>); <span class="comment">// 不会重复添加,每个值都是唯一的,重复的值会被忽略.</span></span><br><span class="line">set.<span class="title function_">delete</span>(<span class="number">3</span>); <span class="comment">// 从 Set 中删除一个值.</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(set.<span class="title function_">has</span>(<span class="number">1</span>)); <span class="comment">// 检查 Set 中是否存在某个值.</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(set.<span class="property">size</span>); <span class="comment">// 返回 Set 中的值的数量.</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> set) &#123; <span class="comment">// 可以用for of 遍历</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(value);</span><br><span class="line">&#125;</span><br><span class="line">set.<span class="title function_">clear</span>() <span class="comment">//  清空 Set</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><h4 id="普通函数"><a href="#普通函数" class="headerlink" title="普通函数"></a>普通函数</h4><ul>
<li>回调函数：是一个作为参数传递给另一个函数的函数<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 模块A</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getData</span>(<span class="params">callBack</span>)&#123;</span><br><span class="line">  <span class="keyword">let</span> status = <span class="number">404</span>;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    status = <span class="number">200</span></span><br><span class="line">    <span class="title function_">callBack</span>(status)</span><br><span class="line">  &#125;,<span class="number">1000</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">getData</span>(dealData); <span class="comment">// 模块B传入模块A</span></span><br><span class="line"><span class="comment">// 模块B</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">dealData</span>(<span class="params">num</span>)&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;i get the number:&#x27;</span> + num)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>arguments 用法：是 JavaScript 函数内部的一个 类数组对象(array-like object)，用于存储所有传入函数的参数。它只可以在 非箭头函数 中使用<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">test</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">arguments</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">arguments</span>[<span class="number">0</span>]); <span class="comment">// 第一个参数</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">arguments</span>[<span class="number">1</span>]); <span class="comment">// 第二个参数</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">arguments</span>.<span class="property">length</span>); <span class="comment">// 参数个数</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> args = [...<span class="variable language_">arguments</span>]; <span class="comment">// 用扩展运算符转换为数组</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(args);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">test</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>); </span><br><span class="line"><span class="comment">// 输出：Arguments(3) [1, 2, 3, callee: ƒ, Symbol(Symbol.iterator): ƒ]</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="function构造函数"><a href="#function构造函数" class="headerlink" title="function构造函数"></a>function构造函数</h4>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">People</span> (name,sex)&#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">sex</span> = sex</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">People</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayName</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="class构造函数-本质仍然是function的语法糖"><a href="#class构造函数-本质仍然是function的语法糖" class="headerlink" title="class构造函数(本质仍然是function的语法糖)"></a>class构造函数(本质仍然是function的语法糖)</h4>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name,sex</span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">sex</span> = sex</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">sayName</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Superman</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Person</span>&#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name,sex,skill</span>)&#123;</span><br><span class="line">    <span class="variable language_">super</span>(name,sex)</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">skill</span> = skill</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">useSkill</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">skill</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="bind-和call-与apply-区别"><a href="#bind-和call-与apply-区别" class="headerlink" title="bind()和call()与apply()区别:"></a>bind()和call()与apply()区别:</h4><ul>
<li>call 和 apply 主要用于 改变 this 指向，它们可以让一个对象借用另一个对象的方法。它们的主要区别在于 参数传递的方式不同。</li>
<li>bind 也是改变 this 的方法，但它不会立即执行函数，而是返回一个新的函数：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// func.call(thisArg, arg1, arg2, ...);</span></span><br><span class="line"><span class="keyword">const</span> person1 = &#123; <span class="attr">name</span>: <span class="string">&quot;Alice&quot;</span> &#125;;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sayHello</span>(<span class="params">age</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Hello, my name is <span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span> and I am <span class="subst">$&#123;age&#125;</span> years old.`</span>);</span><br><span class="line">&#125;</span><br><span class="line">sayHello.<span class="title function_">call</span>(person1, <span class="number">25</span>); <span class="comment">// Hello, my name is Alice and I am 25 years old.</span></span><br><span class="line"><span class="comment">// func.apply(thisArg, [arg1, arg2, ...]); 参数必须用数组传递！</span></span><br><span class="line">sayHello.<span class="title function_">apply</span>(person1, [<span class="number">25</span>]); <span class="comment">// Hello, my name is Alice and I am 25 years old.</span></span><br><span class="line"><span class="comment">// func.bind(thisArg, arg1, arg2, ...);</span></span><br><span class="line"><span class="keyword">const</span> boundFunc = sayHello.<span class="title function_">bind</span>(person1, <span class="number">25</span>);</span><br><span class="line"><span class="title function_">boundFunc</span>(); <span class="comment">// Hello, my name is Alice and I am 25 years old.</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="浏览器API"><a href="#浏览器API" class="headerlink" title="浏览器API"></a>浏览器API</h3><h4 id="ajax如何创建和使用"><a href="#ajax如何创建和使用" class="headerlink" title="ajax如何创建和使用"></a>ajax如何创建和使用</h4><ol>
<li>实例化XMLHttpRequest对象:    </li>
<li>open()准备发送求:            </li>
<li>send()执行发送动作:                </li>
<li>onreadystatechange指定回调函数接收来自服务器端的请求,readyState即为回调状态 responseText返回内容</li>
</ol>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> http = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">http.<span class="title function_">open</span>(post,<span class="string">&quot;https://www.baidu.com&quot;</span>,<span class="literal">false</span>)</span><br><span class="line"><span class="comment">//http.open(method,url,async);</span></span><br><span class="line">http.<span class="title function_">send</span>();</span><br><span class="line">http.<span class="property">onreadystatechange</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">if</span>(http.<span class="property">status</span> === <span class="number">200</span> &amp;&amp; http.<span class="property">readyState</span> === <span class="number">4</span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(http.<span class="property">responseText</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="本地存储与Cookie的区别"><a href="#本地存储与Cookie的区别" class="headerlink" title="本地存储与Cookie的区别"></a>本地存储与Cookie的区别</h4><ul>
<li>Cookie:它有4kb的大小限制,数据的生命周期比较灵活,不设置失效时间默认关闭浏览器后失效,原生Cokkie接口不好需要二次封装,可以通过它设置记住密码功能,存储的内容会保留在HTTP请求的Header中,并且会随每次请求发送到浏览器</li>
<li>本地储存:是HTML5新增技术,有localStorage和sessionStorage两种,他们可存储的大小为5mb,localStorage的生命周期是永久存储,sessionStorage的生命周期是当页面关闭后销毁</li>
</ul>
<h4 id="Json如何新增-删除键值对"><a href="#Json如何新增-删除键值对" class="headerlink" title="Json如何新增&#x2F;删除键值对"></a>Json如何新增&#x2F;删除键值对</h4><ul>
<li>新增:<ul>
<li>使用数组下标形式添加 Object[“属性名”] &#x3D;’xxx’;</li>
<li>使用对象参数的形式添加 Object.属性名 &#x3D; ‘xxx’;</li>
</ul>
</li>
<li>删除:<ul>
<li>使用delete删除 delete Object.属性名</li>
</ul>
</li>
</ul>
<h4 id="ES6新特性"><a href="#ES6新特性" class="headerlink" title="ES6新特性"></a>ES6新特性</h4><ul>
<li>const和let<ul>
<li>Let与var与const的区别<ul>
<li>var声明的变量会挂载在window上,而let和const声明的变量不会</li>
<li>var声明变量存在变量提升,let和const不存在变量提升</li>
<li>let和const声明形成块级作用域</li>
<li>同一作用域下let和const不能声明同名变量,而var可以</li>
<li>let 有暂存死区</li>
</ul>
</li>
</ul>
</li>
<li>模板字符串</li>
<li>箭头函数</li>
<li>函数的参数默认值</li>
<li>对象和数组解构</li>
<li>for…of 和 for…in</li>
<li>ES6中的类</li>
<li>Promise对象</li>
<li>async函数</li>
</ul>
<h3 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h3><h4 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h4><ul>
<li>概念: 写一段自调用函数,函数体内声明变量后return出一个方法,在方法内引用数据并处理,之后随着函数的调用结束定义的数据不会被而释放,第一次调用后的值被保存了下来,所以形成了”闭包”.</li>
<li>原因：因为当声明一段函数时,它的作用域和变量就已经在内存中被声明了,因为js的垃圾处理机制是被引用的堆内存不会被释放.所以当变量被函数内部引用,函数执行完毕后作用域被销毁,但被引用的值不会被销毁,所以这些变量在闭包执行期间是永久性存在的</li>
<li>特性:<ol>
<li>函数内变量以私有成员的存在,避免了全局变量的污染</li>
<li>函数内部可以引用外部的参数和变量</li>
<li>这些变量的值始终保持在内存中,不会在外层函数调用后被自动清除</li>
<li>参数和变量不会被垃圾回收机制回收</li>
</ol>
</li>
<li>影响:<ul>
<li>常驻内存会增大内存的使用量,造成内存泄露</li>
</ul>
</li>
<li>用途:<ul>
<li>保存状态:<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这样并不会污染全局作用域,但是数据却可以拿到</span></span><br><span class="line"><span class="keyword">const</span> countNum = (<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    a += <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> a </span><br><span class="line">  &#125;</span><br><span class="line">&#125;)()</span><br><span class="line"><span class="title function_">countNum</span>(); <span class="comment">// 1</span></span><br><span class="line"><span class="title function_">countNum</span>(); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure></li>
<li>模块化:<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// moduleA.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> moduleA = (<span class="function">()=&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> data = <span class="string">&quot;this is my data&quot;</span>;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">getData</span>:<span class="function">()=&gt;</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> data</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)()</span><br><span class="line"><span class="comment">// moduleB.js</span></span><br><span class="line"><span class="keyword">import</span> moduleA <span class="keyword">from</span> moduleA.<span class="property">js</span></span><br><span class="line"><span class="keyword">const</span> data = moduleA.<span class="title function_">getData</span>() + <span class="string">&quot;deal&quot;</span>;</span><br><span class="line">...</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h4 id="什么是内存泄露"><a href="#什么是内存泄露" class="headerlink" title="什么是内存泄露?"></a>什么是内存泄露?</h4><ul>
<li>内存因为某些原因没有被垃圾回收装置回收成为常驻内存,造成系统内存的浪费,可能会导致程序运行速度减慢甚至崩溃</li>
</ul>
<h4 id="原型-原型链-继承"><a href="#原型-原型链-继承" class="headerlink" title="原型&#x2F;原型链&#x2F;继承"></a>原型&#x2F;原型链&#x2F;继承</h4><ul>
<li>概念:<ul>
<li>原型: 在JS中每个构造函数有一个原型对象,构造函数可以通过prototype去访问原型对象,而原型对象有一个constructor指回构造函数,构造函数可以生成一个实例,生成的实例有一个__proto__属性指向原型对象.</li>
<li>原型链:当访问JS中一个实例的方法和属性时,首先会查找自身；如果并未查找到,那么就会寻找实例的原型对象中是否存在,如果仍不存在,就会访问原型对象的原型对象.这个搜索链条就叫原型链<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">People</span>(<span class="params">name,sex</span>)&#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">sex</span> = sex</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">People</span>.<span class="property"><span class="keyword">prototype</span></span> <span class="comment">// 原型对象</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>用途:<ul>
<li>用于继承<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Animal</span> ()&#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">step</span> = <span class="number">0</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">category</span> = <span class="string">&quot;animal&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Animal</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">run</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">step</span> += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Dog</span>(<span class="params">name</span>)&#123;</span><br><span class="line">  <span class="title class_">Animal</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>); <span class="comment">// 实现Animal属性的继承</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使原型链继承</span></span><br><span class="line"><span class="title class_">Dog</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="title class_">Animal</span>.<span class="property"><span class="keyword">prototype</span></span>)</span><br><span class="line"><span class="title class_">Dog</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">construtor</span> = <span class="title class_">Dog</span>;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Dog</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">say</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;woof&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> xiaobai = <span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="string">&quot;xiaobai&quot;</span>)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>继承:是面向对象编程中的一个重要概念,通过继承可以使子类的实例使用在父类中定义的属性和方法.[每当代码读取某个对象的某个属性时,都会执行一次搜索,目标是具有给定名字的属性.搜索首先从对象实例本身开始.如果在实例中找到了具有给定名字的属性,则返回该属性的值；如果没有找到,则继续搜索_proto_指针指向的原型对象,在原型对象中查找具有给定名字的属性.如果在原型对象中找到了这个属性,则返回该属性的值.]</li>
</ul>
<h4 id="同步与异步的区别-阻塞与非阻塞区别"><a href="#同步与异步的区别-阻塞与非阻塞区别" class="headerlink" title="同步与异步的区别&#x2F;阻塞与非阻塞区别"></a>同步与异步的区别&#x2F;阻塞与非阻塞区别</h4><blockquote>
<p>(<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_22855325/article/details/72958345">https://blog.csdn.net/qq_22855325/article/details/72958345</a>)</p>
</blockquote>
<ul>
<li>同步任务指的是,在主线程上排队执行的任务,只有前一个任务执行完毕,才能执行下一个任务；</li>
<li>异步任务指的是,不进入主线程、而进入”任务队列”,只有等主线程任务执行完毕,”任务队列”才开始通知主线程,请求执行任务,该任务才会进入主线程执行<br>  [javascript是单线程,所有任务需要排队,前一个任务结束,才会执行后一个任务]</li>
<li>阻塞:调用时,如果被调用者状态未就绪,会导致调用线程被挂起.</li>
<li>非阻塞:调用时,如果被调用者就绪则立即返回结果,如果未就绪也会返回一个错误值,告诉调用者当前的状态</li>
</ul>
<h4 id="请简述async的用法"><a href="#请简述async的用法" class="headerlink" title="请简述async的用法"></a>请简述async的用法</h4><blockquote>
<p>(<a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000007535316">https://segmentfault.com/a/1190000007535316</a>)</p>
</blockquote>
<ul>
<li>async用于申明一个函数是异步的并且它会返回一个Promise对象,函数的返回值就是.then()里的数值<br>  [await只能出现在async函数中,await在等待一个async函数完成,因为 async 函数返回一个 Promise 对象,所以 await 可以用于等待一个 async 函数的返回值——这也可以说是 await 在等 async 函数,但要清楚,它等的实际是一个返回值]</li>
</ul>
<h4 id="什么是JSONP工作原理是什么"><a href="#什么是JSONP工作原理是什么" class="headerlink" title="什么是JSONP工作原理是什么?"></a>什么是JSONP工作原理是什么?</h4><ul>
<li>工作原理: 通过 script 标签绕过同源策略 前端动态生成一个script标签向后端发送get请求,然后准备函数接收数据,并用callback为键将函数名发送给后端,后端接收函数名后将数据作为实参拼接一段执行调用函数的js代码返回给前端,前端接收到执行函数的代码后 script标签 会自动调用声明的函数,函数的形参就是后端返回的数据.<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 前端请求 &lt;script src=&quot;https://example.com/api?callback=dealData&quot;&gt;&lt;/script&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 服务器返回</span></span><br><span class="line"><span class="title function_">dealData</span>(&#123; <span class="attr">name</span>: <span class="string">&quot;Alice&quot;</span>, <span class="attr">age</span>: <span class="number">25</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 前端接收</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">dealData</span>(<span class="params">data</span>)&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(data)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="事件委托是什么-如何确定事件源"><a href="#事件委托是什么-如何确定事件源" class="headerlink" title="事件委托是什么?如何确定事件源"></a>事件委托是什么?如何确定事件源</h4><ul>
<li>事件委托就是利用事件冒泡机制,只给一个元素绑定事件,就可以代理管理某一类型的所有事件.<br>  事件源通过事件对象的target属性来确定</li>
</ul>
<h4 id="This指向"><a href="#This指向" class="headerlink" title="This指向"></a>This指向</h4><ol>
<li>在一般函数内或全局作用域下,指向的window对象</li>
<li>在对象的方法中,指向的该对象</li>
<li>在事件处理函数中,指向触发事件的元素(Node节点)</li>
<li>在箭头函数中: 继承上一级的指向位置(无视当前函数)</li>
<li>在构造函数中,指向的是实例化对象.(需要new的对象)  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">People</span>(<span class="params">name,age</span>)&#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">sayMyName</span> = <span class="title function_">alert</span>(name);</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> student = <span class="keyword">new</span> <span class="title class_">People</span>(<span class="string">&quot;二狗&quot;</span>,<span class="number">18</span>);</span><br><span class="line">student.<span class="property">sayMyName</span></span><br></pre></td></tr></table></figure></li>
<li>在新增原型对象属性中,this指的就是这个原型的主人(实例化的对象)</li>
</ol>
<h4 id="箭头函数与普通函数的区别"><a href="#箭头函数与普通函数的区别" class="headerlink" title="箭头函数与普通函数的区别"></a>箭头函数与普通函数的区别</h4><ul>
<li>箭头函数都是匿名函数,没有自己this,arguments,原型对象</li>
</ul>
<h4 id="普通函数和构造函数的区别"><a href="#普通函数和构造函数的区别" class="headerlink" title="普通函数和构造函数的区别"></a>普通函数和构造函数的区别</h4><ol>
<li>写法不同构造函数习惯上首字母大写</li>
<li>调用方式不一样,普通函数可以用 函数名() 的形式直接调用,构造函数需要用new关键字来调用创建实例对象</li>
<li>返回值不一样,普通函数返回值由return决定,构造函数返回值是实例化的对象</li>
</ol>
<h4 id="什么是面向对象请简述"><a href="#什么是面向对象请简述" class="headerlink" title="什么是面向对象请简述"></a>什么是面向对象请简述</h4><ul>
<li>面向对象的三大特征 继承、封装、多态<ul>
<li>继承:通过继承使子类可以使用在父类中定义的属性和方法</li>
<li>封装:就是指把内部的实现封装起来,然后暴露必要的方法让外部调用.</li>
<li>多态:多态指的是同一类事物有多种形态,如文件有:文本文件,可执行文件,视频文件等…</li>
</ul>
</li>
</ul>
<h4 id="重绘以及回流是什么"><a href="#重绘以及回流是什么" class="headerlink" title="重绘以及回流是什么"></a>重绘以及回流是什么</h4><ul>
<li>重绘(repaint):当元素样式的改变不影响布局时,浏览器将使用重绘对元素进行更新,此时由于只需要UI层面的重新像素绘制,因此损耗较少,常见的重绘操作有:改变元素颜色</li>
<li>回流(reflow):当元素的尺寸、结构或者触发某些属性时,浏览器会重新渲染页面,称为回流.此时,浏览器需要重新经过计算,计算后还需要重新页面布局,因此是较重的操作.常见的回流操作有:浏览器窗口大小改变,添加或者删除可见的DOM元素</li>
<li>回流必定会触发重绘,重绘不一定会触发回流.重绘的开销较小,回流的代价较高.</li>
</ul>
<h4 id="事件循环-Event-Loop"><a href="#事件循环-Event-Loop" class="headerlink" title="事件循环(Event Loop)"></a>事件循环(Event Loop)</h4><ul>
<li>解释: JS是单线程的语言,为了避免阻塞主线,它引入了事件循环机制来处理异步任务,JS会先执行同步任务,遇到异步任务的时候会交给Web API,当异步任务执行完成的时候,会将回调函数放入 任务队列 Task Queue &#x2F; Callback Queue 然后 Event Loop 事件循环 负责一直监听任务队列 执行队列中的任务</li>
<li>宏任务微任务:遇到同步任务直接执行,遇到异步任务分类为宏任务(macro-task)和微任务(micro-task).有微则微,无微则宏:<ul>
<li>宏任务: 整体代码 定时器 ajax DOM事件</li>
<li>微任务: promise async&#x2F;await</li>
</ul>
</li>
<li>微任务 &gt; DOM渲染 &gt; 宏任务</li>
</ul>
<h4 id="深浅拷贝"><a href="#深浅拷贝" class="headerlink" title="深浅拷贝"></a>深浅拷贝</h4><ul>
<li>是什么如何实现?<ul>
<li>js有两种类型基本类型和引用类型,基本类型它的名和值会储存在栈内存中,当我们复制它时会开一条新内存再创建一个同样的值,但是引用类型在我们新建的时候它会在栈内存中储存它的名和一个指向它堆内存的地址,当我们复制的时候其实只是复制了它的引用地址并非堆里面的值,如果要深拷贝我们就需要新建一个和它一样的堆内存的值</li>
</ul>
</li>
<li>什么时候用深拷贝&#x2F;浅拷贝<ul>
<li>当我们创建了一个对象并复制,如果我们想修改复制的对象,但却不想让原对象也随之改变的时候使用深拷贝,但是如果我们只是想复制它的基本类型的数据或者指向它的堆内存的指针的时候使用浅拷贝</li>
</ul>
</li>
<li>深拷贝的代码实现<ul>
<li>简单深拷贝(一层拷贝)  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">deepCopy</span>(<span class="params">obj</span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> copyObj = <span class="title class_">Array</span>.<span class="title function_">isArray</span>(obj) ? [] : &#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">in</span> obj)&#123;</span><br><span class="line">        copyObj[key] = obj[key];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> copyObj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>复杂深拷贝(递归实现多层拷贝)  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">deepCopy</span>(<span class="params">obj</span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> copyObj = <span class="title class_">Array</span>.<span class="title function_">isArray</span>(obj) ? [] : &#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">in</span> obj)&#123;</span><br><span class="line">        <span class="keyword">if</span>( obj.<span class="title function_">hasOwnProperty</span>(key) )&#123;</span><br><span class="line">            copyObj[key] = <span class="keyword">typeof</span> obj[key] === <span class="string">&#x27;object&#x27;</span> ? <span class="title function_">deepCopy</span>(obj[key]) : obj[key] ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> copyObj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h4 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h4><ul>
<li>理解: promise是为解决异步处理回调地狱问题而产生的;它是一个构造函数,可以通过new得到一个Promise的实例对象,Promise里有两个函数分别叫做resolve(成功之后的回调函数)和reject(失败之后的回调函数)在Promise构造函数的Prototype属性上,有一个.then()和.catch()方法,只要是Promise的实例化对象都可以使用</li>
<li>Promise在哪里使用过<ul>
<li>在使用ajax,axios等一类的数据请求的时候用过,只要是一些需要解决回调函数问题的都可以用(在函数中return一个promise实例,成功后干嘛失败后干嘛,则该函数就可以使用.then和catch方法)</li>
</ul>
</li>
</ul>
<h4 id="函数节流和函数防抖-优化高频率执行js代码的一种手段"><a href="#函数节流和函数防抖-优化高频率执行js代码的一种手段" class="headerlink" title="函数节流和函数防抖(优化高频率执行js代码的一种手段)"></a>函数节流和函数防抖(优化高频率执行js代码的一种手段)</h4><ul>
<li>函数节流:<blockquote>
<p>(<a target="_blank" rel="noopener" href="https://www.cnblogs.com/fightjianxian/p/12077570.html">https://www.cnblogs.com/fightjianxian/p/12077570.html</a>)</p>
</blockquote>
<ul>
<li>作用: 在 n 秒中只执行一次函数(指定时间间隔内只会执行一次任务)</li>
<li>实现:<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数节流</span></span><br><span class="line"><span class="keyword">var</span> pass = <span class="literal">true</span>;</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;throttle&quot;</span>).<span class="property">onscroll</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(!pass)&#123;</span><br><span class="line">    <span class="comment">// 判断是否已空闲,如果在执行中,则直接return</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pass = <span class="literal">false</span>;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;函数节流&quot;</span>);</span><br><span class="line">        pass = <span class="literal">true</span>;</span><br><span class="line">    &#125;, <span class="number">300</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li>应用场景: 高频触发的事件,多数在监听页面元素滚动事件</li>
</ul>
</li>
<li>函数防抖:<blockquote>
<p>(<a target="_blank" rel="noopener" href="https://www.cnblogs.com/fightjianxian/p/12077451.html">https://www.cnblogs.com/fightjianxian/p/12077451.html</a>)</p>
</blockquote>
<ul>
<li>作用: 在 n 秒内函数只能执行一次,如果在 n 秒内又触发了事件,则会重新计算函数执行时间(任务频繁触发的情况下,只有任务触发的间隔超过指定间隔,任务才会执行)</li>
<li>实现:<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> timer = <span class="literal">false</span>;</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;debounce&quot;</span>).<span class="property">onscroll</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="built_in">clearTimeout</span>(timer); <span class="comment">// 清除未执行的代码,重置回初始化状态</span></span><br><span class="line">    timer = <span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;函数防抖&quot;</span>);</span><br><span class="line">    &#125;, <span class="number">300</span>);</span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure></li>
<li>应用场景:如邮箱验证和手机号验证.只有等用户输入完毕后,前端才需要检查格式是否正确,如果不正确,再弹出提示语</li>
</ul>
</li>
</ul>
<h3 id="VUE"><a href="#VUE" class="headerlink" title="VUE"></a>VUE</h3><h4 id="VUE2"><a href="#VUE2" class="headerlink" title="VUE2"></a>VUE2</h4><ul>
<li><p>Vue的核心是什么</p>
<ul>
<li>数据驱动和组件化</li>
<li>数据驱动:视图的内容随着数据的改变而改变</li>
<li>组件化:把页面封装成为若干个组件进行拼装,让页面的复用性达到最高</li>
</ul>
</li>
<li><p>请简述你对vue的理解</p>
<ul>
<li>一套渐进式的自底向上增量开发的前端MVVM框架<ul>
<li>渐进式:可以只使用部分功能,也可以整个用vue开发,不做职责之外的事</li>
<li>自底向上增量开发:先编写出基础页面,再逐步扩大规模,补充和升级某些功能和效果</li>
<li>M代表模型层也是数据层V代表视图层,VM是用来沟通的桥梁,负责监听模型层或者视图层的修改</li>
</ul>
</li>
</ul>
</li>
<li><p>mvvm框架是什么?它和其它框架(jquery)的区别是什么?哪些场景适合?</p>
<ul>
<li>M代表数据层V代表视图层,VM是用来沟通的桥梁,负责监听模型层或者视图层的修改</li>
<li>区别:vue数据驱动,通过数据来显示视图层而不是节点操作. </li>
<li>场景:数据操作比较多的场景,更加便捷.</li>
</ul>
</li>
<li><p>MVVM与MVC的区别</p>
<ul>
<li>MVC中Model和View还有Controller是完全独立的,由Controller作为中间人来负责二者的交互</li>
<li>MVVM中VM是V与M沟通的桥梁,开发者只需关注业务逻辑,不需要手动操作DOM,不需要关注数据状态的同步问题,复杂的数据状态维护完全由MVVM来管理</li>
</ul>
</li>
<li><p>请简述vue的单向数据流</p>
<ul>
<li>组件之间一旦传值完毕,接收数据的这个组件无论怎么修改,传递数据的那个组件的数据都不会改变;我们经常会采用父子组件通过正向&#x2F;逆向传值来对数据进行传递.以上的这些模式非常脆弱,通常会导致无法维护的代码.</li>
</ul>
</li>
<li><p>Vue常用的修饰符有哪些</p>
<ul>
<li>事件修饰符:<ul>
<li>prevent(阻止事件的默认行为)</li>
<li>stop(阻止事件冒泡)</li>
<li>capture(让事件传递成为捕获)</li>
<li>self(只会触发自己范围内的事件,不包含子元素)</li>
<li>once(只会触发一次)</li>
</ul>
</li>
<li>按键修饰符(按下某个键):up down ctrl enter space</li>
</ul>
</li>
<li><p>什么是计算属性</p>
<ul>
<li>它是一种属性,有“计算”这个特殊性质.每次取得它的值得时候,它并不像普通属性那样直接返回结果,而是经过一系列的计算之后再返回结果.</li>
</ul>
</li>
<li><p>计算属性与watch区别</p>
<ul>
<li>计算属性是依赖于缓存的,当依赖的值发生改变才会触发.而watch是当watch监听的值发生改变就会被调用相应方法</li>
<li>计算属性适合在数据展示时做一些处理</li>
</ul>
</li>
<li><p>Vue如何定义一个过滤器</p>
<ul>
<li>&#96;全局过滤器使用Vue.filter(‘过滤器名字’,function(val){return 返回的内容})在app.vue中</li>
<li>局部过滤器使用filters(‘’,function(val){})在data同级</li>
<li>通过 { { 要过滤的数据|过滤器名 } }来调用</li>
</ul>
</li>
<li><p>Vue循环的key作用</p>
<ul>
<li>key的作用主要是为了高效的更新虚拟DOM,是遍历数组或元素中的唯一标识,增加或删减元素时,通过key判断是否是之前的元素,如果是则直接会复用该标签,不会将所有标签重新删除和创建,只会重新渲染数据,然后再创建新的元素直到数据渲染完为止</li>
</ul>
</li>
<li><p>v-for与v-if优先级</p>
<ul>
<li>v-for比v-if具有更高的优先级,但是不能把v-if与v-for用在同一个元素上,因为如果两者同时出现的话,那每次循环都会执行v-if,会很浪费性能</li>
</ul>
</li>
<li><p>Vue单页面的优缺点</p>
<ul>
<li>优点:用户体验好,速度快,内容的改变不需要再加载整个页面,前后端分离,组件化便于修改和调整</li>
<li>缺点:初次加载耗时高,页面复杂度提高,导航需要自行实现前进后退,不利于seo搜索引擎优化</li>
</ul>
</li>
<li><p>Vue的生命周期请简述</p>
<ul>
<li>beforeCreate:创建vue实例前</li>
<li>created:创建实例完成后,开始监听data对象数据变化情况,初始化VUE内部事件</li>
<li>beforeMount:编译模板,把data里面的数据和模板生成html</li>
<li>mounted:用编译好的html替换掉el属性所指向的DOM对象</li>
<li>beforeUpate:数据更新前</li>
<li>updated:数据更新后</li>
<li>beforedestroy:销毁实例前</li>
<li>destroyed:销毁所有事件监听器和子实例,完成销毁vue实例</li>
</ul>
</li>
<li><p>Vue生命周期的作用:</p>
<ul>
<li>给使用者在不同阶段添加自己的代码的机会</li>
</ul>
</li>
<li><p>DOM渲染在那个生命周期阶段内完成</p>
<ul>
<li>mounted</li>
</ul>
</li>
<li><p>Vue中路由跳转方式(声明式&#x2F;编程式)</p>
<ul>
<li>声明式: <router-link></li>
<li>编程式: this.$router.push(“&#x2F;路由名”)</li>
</ul>
</li>
<li><p>跨域的解决方式</p>
<ol>
<li>在vue.config.js中进行proxy配置</li>
<li>在后台用cors跨域</li>
</ol>
</li>
<li><p>Vue路由的实现</p>
<ul>
<li>通过hash和history两种模式来实现,它们分别基于location和history对象</li>
</ul>
</li>
<li><p>Vue路由模式hash和history,简单讲一下</p>
<ul>
<li>hash模式:基于location对象,地址栏会出现#(hash)符,只有#前的内容会被包含在请求中,前端路由修改的是#后的信息,所以刷新是不会向服务端请求添加#后面的参数,所以刷新不会出问题</li>
<li>history模式:基于History对象,前端的URL必须和实际向后端发起请求的URL一致,不然会出现404错误(比如刷新的时候),需要后端配置一下apache或是nginx的url重定向,重定向到我的首页路由上.</li>
</ul>
</li>
<li><p>Vue路由懒加载(按需加载路由)</p>
<ul>
<li>因为vue的路由技术是为了完成单页面应用的,在第一次页面初始化的时候路由会把所有的路由页面都渲染好可能会造成用户的页面白屏相应慢: component:()&#x3D;&gt;import(‘路由组件路径’)</li>
</ul>
</li>
<li><p>Route与router区别</p>
<ul>
<li>route对象表示当前的路由信息,是一个局部对象,包含了当前URL解析得到的信息.包含当前的路径,参数,query对象等.</li>
<li>router对象是全局路由的实例,他包含所有的路由拥有的对应的对象,属性和方法.比如history对象</li>
</ul>
</li>
<li><p>Vue路由传参的两种方式,prams和query方式与区别</p>
<ul>
<li>params:需要在路由规则中绑定接收的参数名,通过路由规则的name值来绑定发送的参数,传递的参数不会暴露在地址栏相对安全</li>
<li>query:不需要在路由规则中绑定参数名,通过路由规则的path路径来绑定发送的参数,传递的参数会暴露在地址栏不安全</li>
</ul>
</li>
<li><p>Vue数据绑定的几种方式</p>
<ul>
<li>普通文本绑定v-text</li>
<li>解释HTML标签的绑定v-html</li>
<li>数据特殊属性v-bind</li>
<li>双向绑定 v-model</li>
</ul>
</li>
<li><p>Vue注册一个全局组件</p>
<ol>
<li>在main.js通过import引入封装的组件</li>
<li>使用vue.component(“设置使用时的组件名”,引入的组件)</li>
</ol>
</li>
<li><p>Vue的路由钩子函数&#x2F;路由守卫有哪些</p>
<ul>
<li>全局钩子:<ul>
<li>路由前置:router.beforeEach((to,from,next)&#x3D;&gt;{})</li>
<li>路由后置:router.afterEach((to,from,next)&#x3D;&gt;{})</li>
</ul>
</li>
<li>路由独享钩子:在路由规则中写入 只有前置beforeEnter:(to,from,next)&#x3D;&gt;{}</li>
<li>组件内钩子:beforeRouteEnter(to,from,next){} beforeRouteLeave(to,from,next){}</li>
</ul>
</li>
<li><p>Vue中如何进行动态路由设置?有哪些方式?怎么获取传递过来的数据?</p>
<ul>
<li>前端列表页点击之后通过params或query的声明式(<router-link to=""></router-link>)或编程式发送参数(this.$router.push(name&#x2F;路径,params&#x2F;query:{}))如果使用params传参需要在路由规则中配置接收参数的参数名</li>
<li>最后详情页再通过this.$route.params&#x2F;query.接收的参数名后 发送不同参数的请求接收不同的数据渲染页面</li>
</ul>
</li>
<li><p>Vue中指令有哪些</p>
<ul>
<li>v-text 将普通数据显示在页面上</li>
<li>v-html 输出html内容</li>
<li>v-show 控制元素的显示和隐藏</li>
<li>v-if 判断是否加载内容 v-else-if:满足一项先执行它 v-else:不然就执行它</li>
<li>v-model 用于表单的双向绑定</li>
<li>v-for 遍历数据</li>
<li>v-bind 绑定特殊属性</li>
<li>v-once 只渲染一次 数据改变不会影响该值的变化</li>
<li>v-on 绑定事件</li>
</ul>
</li>
<li><p>v-on可以绑定多个方法吗</p>
<ul>
<li>可以 使用v-on”{ click:dbclick,mouseomve:mouseclick }”</li>
</ul>
</li>
<li><p>Vue-cli中如何自定义指令</p>
<ul>
<li>自定义指令有5个钩子;<ul>
<li>bind代表绑定指令到元素上,只执行一次</li>
<li>inserted代表绑定指令的元素插入到页面时就调用(常用)</li>
<li>componentUpdated:指令所在组件的节点及其子节点全部更新完成后调用</li>
<li>update:所有组件节点更新时调用</li>
<li>unbind:解除指令和元素的绑定,只执行一次</li>
</ul>
</li>
<li>如果时局部指令使用directives:{ 自定义指令的名字:{ 钩子函数(el){ 操作逻辑 } } }写在data同级</li>
<li>如果时全局使用Vue.directive(‘自定义的名字’,{钩子函数(el){ 操作逻辑 } })</li>
</ul>
</li>
<li><p>Watch请简述</p>
<ul>
<li>监听data模型数据 当模型数据改变的时候就会触发;watch初始化的时候不会运行,只有数据被改变之后才会运行</li>
</ul>
</li>
<li><p>v-text与区别{ { } }</p>
<ul>
<li>{ { } }是模板插值,v-text是指令,模板插值 { { } } 如果数据过多可能会把大括号显示出来(屏幕闪动)需要使用v-cloak指令</li>
</ul>
</li>
<li><p>对vue中keep-alive的理解</p>
<ul>
<li>切换过程中将状态保留在内存中,防止重复渲染DOM,减少加载时间及性能消耗,提高用户体验性</li>
<li>用<keep-alive>元素将其路由出口包裹起来;它有两个钩子函数 activated(激活后)和deactivated(停用后)</li>
</ul>
</li>
<li><p>如何让组件中的css在当前组件生效</p>
<ul>
<li>在组件中的style前面加上scoped</li>
</ul>
</li>
<li><p>Vue组件中的data为什么是函数</p>
<ul>
<li>data数据会以函数返回值形式定义,这样每复用一次组件,就会返回一份新的data,相当于给每个组件实例创建一个私有的数据空间,让各个组件实例维护各自的数据.如果是对象形式,就使得所有组件实例共用了一份data,就会造成数据的公用的结果.</li>
</ul>
</li>
<li><p>Vue双数据绑定过程中,这边儿数据改变了怎么通知另一边改变</p>
<ul>
<li>当我们读取或者设置对象属性的时候,都会触发Object.defineProperty()函数的get和set方法,在这两个方法中添加操作从而劫持数据,当属性发生变化的时候,会执行一系列的渲染视图操作</li>
</ul>
</li>
<li><p>Vue双向绑定的原理</p>
<ul>
<li>数据劫持:当我们读取或者设置对象属性的时候,都会触发Object.defineProperty()函数的get和set方法,在这两个方法中添加操作从而劫持数据,当属性发生变化的时候,会执行一系列的渲染视图操作</li>
<li>发布者订阅模式:对象间一种一对多的依赖关系,当一个对象的状态发生改变时,所有依赖于它的对象都将得到通知.</li>
</ul>
</li>
<li><p>Vue中组件怎么传值</p>
<ul>
<li>正向传值:<ol>
<li>在子组件用props新建一个数据名并使用,来接收父组件传过来的值</li>
<li>在父组件中使用子组件,并以特殊属性的方式,把需要传递的数据通过props数据名传递给子组件</li>
</ol>
</li>
<li>逆向传值:可以使用自定义事件传值 或者ref获取节点传值或vuex传值<ol>
<li>需通过事件函数来触发一个自定义事件: this.$emit(“自定义事件名”,传递的数据)</li>
<li>在使用子组件的父组件中,使用事件绑定指令绑定抛出的自定义事件名并让其等于一个函数,函数的形参就是传递的数据</li>
</ol>
</li>
</ul>
</li>
<li><p>Vue兄弟组件传值</p>
<ul>
<li>可以使用传统的子传父 父再传子的办法或vuex或者eventBus<ol>
<li>在父组件中使用两个子组件让其成为兄弟</li>
<li>在兄弟a引入事件总线,并通过事件函数来触发一个自定义事件 eventBus.$emit(“自定义事件名”,”要传递的数据”)</li>
<li>在兄弟b引入事件总线,在钩子函数中使用eventBus.$on(“自定义事件名”,(val)&#x3D;&gt;{})接收传递的数据,回调函数中的形参就是传递的数据</li>
</ol>
</li>
</ul>
</li>
<li><p>请简述插槽</p>
<ul>
<li>父组件中子组件中数量不同内容也不相同的时候使用的技术;<br>  子组件中插入<slot></slot> 则可在父组件的子组件开标签内部写入标签和内容</li>
</ul>
</li>
<li><p>Vue首屏加载慢的原因,怎么解决的,白屏时间怎么检测,怎么解决白屏问题</p>
<ul>
<li>使用路由懒加载(还有如将第三方依赖打包进入CDN服务器,按需引入ui,压缩代码,精灵图等等)</li>
</ul>
</li>
<li><p>Vuex是什么?怎么使用?在那种场景下使用?</p>
<ul>
<li>状态(数据)管理工具,就是一个数据的仓库,将数据全部存入仓库,组件就可以自由使用数据</li>
<li>将数据保存在state中,通过(this.$store.state.数据名)来调用数据,修改数据在Mutations中,在Actions调用mutations中的方法异步操作数据,在需要使用的组件通过this.$store.dispatch()来调用和传递实参</li>
<li>用于开发中大型web单页应用中对应用的状态进行管理或解决组件间数据通信麻烦的问题</li>
</ul>
</li>
<li><p>vuex的优势</p>
<ol>
<li>能够集中管理和共享数据,易于开发和维护</li>
<li>能够高效地实现组件之间的数据传递,提高开发效率</li>
<li>数据都是响应式的,能够实时保持数据与页面的同步</li>
</ol>
</li>
<li><p>Vuex怎么请求异步数据</p>
<ul>
<li>在action使用封装的axios发送请求,接收到数据后使用commit调用mutation给state数据赋值</li>
</ul>
</li>
<li><p>Vuex中action如何提交给mutation的</p>
<ul>
<li>在组件内通过this.$store.dispatch()调用action的方法并传递实参,在action中使用commit调用mutation方法,通过mutation修改state中的数据</li>
</ul>
</li>
<li><p>vuex有哪几种状态和属性</p>
<ul>
<li>数据保存的地方:State</li>
<li>对数据过滤的:Getter</li>
<li>修改数据的:Mutation</li>
<li>处理异步操作的:Action</li>
<li>让数据模块化的:Module</li>
</ul>
</li>
<li><p>vuex的State特性是?</p>
<ul>
<li>state就是存放数据的仓库,特性就是若store中的state数据发生改变,依赖这个数据的组件也会相应更新(当mutation修改了state的数据的时候,他会动态的去修改所有的调用这个变量的组件里的值)</li>
</ul>
</li>
<li><p>vuex的Getter特性是?</p>
<ul>
<li>getter用来获取数据,类似于计算属性</li>
</ul>
</li>
<li><p>vuex的Mutation特性是?</p>
<ul>
<li>同步执行,修改state数据的唯一途径,直接变更state数据.</li>
</ul>
</li>
<li><p>vuex的actions特性是?</p>
<ul>
<li>用于异步请求数据,不能直接操作state,需要通过提交给mutation来修改state数据</li>
</ul>
</li>
<li><p>$set:解决data数据改变和视图不改变(vue3.0以上已解决,面试常问)</p>
</li>
<li><p>vue中的拖拽+js原生拖拽说思路？</p>
<ol>
<li>需要三个事件 鼠标 按下\移动\抬起</li>
<li>当按下时获取鼠标点击元素的内部鼠标的位置<br>移动时获取鼠标在页面的位置并减去元素内部鼠标的位置,同时判断边界条件,当减去的位置的x轴小于零代表出屏幕的左边,当减去的位置的y轴小于零代表出屏幕的右边,当大于时则需要算出页面的宽度高度(window.innnerXXX)减去元素的宽高度,当大于这个值就等于这个值,<br>当抬起时把移动的事件归位为null</li>
</ol>
</li>
<li><p>vue中assets和public里的静态区别?</p>
<ul>
<li>public放不会变动的文件(相当于vue-cli2.x中的static)public&#x2F; 目录下的文件并不会被Webpack处理:它们会直接被复制到最终的打包目录(默认是dist&#x2F;static)下.必须使用绝对路径引用这些文件,这个取决于你vue.config.js中publicPath的配置,默认的是&#x2F;.</li>
<li>assets放可能会变动的文件assets目录中的文件会被webpack处理解析为模块依赖,只支持相对路径形式.简单来说就是就是public放别人家js文件(也就是不会变动),assets放自己写的js文件(需要改动的文件)</li>
</ul>
</li>
<li><p>怎么提升页面性能?性能优化有哪些?</p>
<ul>
<li>不用将所有的数据都在data中注册,不需要响应式的数据可以定义在实例上</li>
<li>v-for循环生产的代码,要操作dom可以用事件委托</li>
<li>使用keep-alive缓存组件,防止切换路由时来回创建组件浪费性能</li>
<li>如果没有安全性考虑使用v-show代替v-if指令</li>
<li>使用路由懒加载</li>
</ul>
</li>
</ul>
<h4 id="VUE3"><a href="#VUE3" class="headerlink" title="VUE3"></a>VUE3</h4><ul>
<li><p>VUE3的数据劫持原理</p>
<ul>
<li>VUE3采用ES6的Proxy来监听数据的变化,这是一种更彻底的方式,因为它解决了VUE2中使用Object.defineProperty但不能监听数组和对象的增删的问题,Vue2处理数组和对象时,会修改数组的原型的方法,对象的话会通过Vue.set和Vue.delete去手动更新视图。而VUE3中Proxy直接就可以监听对象和数组,不用再这样曲线操作</li>
</ul>
</li>
<li><p>Vue3 组件间如何传值？有哪些方式？</p>
<ul>
<li>props 传值（父 → 子）<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 父组件</span><br><span class="line">&lt;Child :msg=&quot;message&quot; /&gt;</span><br><span class="line">// 子组件</span><br><span class="line">&lt;script setup&gt;</span><br><span class="line">defineProps(&#123;</span><br><span class="line">  msg: String,</span><br><span class="line">&#125;);</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;p&gt;接收到的消息：&#123;&#123; msg &#125;&#125;&lt;/p&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure></li>
<li>emit 事件传值（子 → 父）<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 子组件</span><br><span class="line">&lt;script setup&gt;</span><br><span class="line">const emit = defineEmits([&quot;sendData&quot;]);</span><br><span class="line">function sendMsg() &#123;</span><br><span class="line">  emit(&quot;sendData&quot;, &quot;Hello Parent!&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;button @click=&quot;sendMsg&quot;&gt;发送消息&lt;/button&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">// 父组件</span><br><span class="line">&lt;Child @sendData=&quot;handleData&quot; /&gt;</span><br><span class="line">&lt;script setup&gt;</span><br><span class="line">function handleData(data) &#123;</span><br><span class="line">  console.log(&quot;收到子组件的数据：&quot;, data);</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li>
<li>v-model 进行双向绑定（Vue3 支持多个 v-model，可用于复杂组件。）<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// 父组件</span><br><span class="line">&lt;Child v-model=&quot;text&quot; /&gt;</span><br><span class="line">&lt;script setup&gt;</span><br><span class="line">import &#123; ref &#125; from &quot;vue&quot;;</span><br><span class="line">const text = ref(&quot;Hello&quot;);</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">// 子组件</span><br><span class="line">&lt;script setup&gt;</span><br><span class="line">defineProps([&quot;modelValue&quot;]);</span><br><span class="line">const emit = defineEmits([&quot;update:modelValue&quot;]);</span><br><span class="line">function updateValue() &#123;</span><br><span class="line">  emit(&quot;update:modelValue&quot;, &quot;新的值&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;p&gt;当前值：&#123;&#123; modelValue &#125;&#125;&lt;/p&gt;</span><br><span class="line">  &lt;button @click=&quot;updateValue&quot;&gt;修改值&lt;/button&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// 父组件</span><br><span class="line">&lt;Child v-model:title=&quot;title&quot; v-model:desc=&quot;desc&quot; /&gt;</span><br><span class="line">&lt;script setup&gt;</span><br><span class="line">import &#123; ref &#125; from &quot;vue&quot;;</span><br><span class="line">const title = ref(&quot;Vue3&quot;);</span><br><span class="line">const desc = ref(&quot;双向绑定多个值&quot;);</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">// 子组件</span><br><span class="line">&lt;script setup&gt;</span><br><span class="line">defineProps([&quot;title&quot;, &quot;desc&quot;]);</span><br><span class="line">const emit = defineEmits([&quot;update:title&quot;, &quot;update:desc&quot;]);</span><br><span class="line"></span><br><span class="line">function updateValues() &#123;</span><br><span class="line">  emit(&quot;update:title&quot;, &quot;新标题&quot;);</span><br><span class="line">  emit(&quot;update:desc&quot;, &quot;新描述&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;button @click=&quot;updateValues&quot;&gt;修改值&lt;/button&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure></li>
<li>provide&#x2F;inject 跨组件传值<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 父组件</span><br><span class="line">&lt;script setup&gt;</span><br><span class="line">import &#123; provide, ref &#125; from &quot;vue&quot;;</span><br><span class="line">const theme = ref(&quot;dark&quot;);</span><br><span class="line">provide(&quot;theme&quot;, theme);</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;Child /&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">// 子组件</span><br><span class="line">&lt;script setup&gt;</span><br><span class="line">import &#123; inject &#125; from &quot;vue&quot;;</span><br><span class="line">const theme = inject(&quot;theme&quot;);</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;p&gt;当前主题：&#123;&#123; theme &#125;&#125;&lt;/p&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure></li>
<li>ref 共享数据<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// store.js</span><br><span class="line">import &#123; reactive &#125; from &quot;vue&quot;;</span><br><span class="line">export const globalState = reactive(&#123; count: 0 &#125;);</span><br><span class="line">// 组件 A</span><br><span class="line">&lt;script setup&gt;</span><br><span class="line">import &#123; globalState &#125; from &quot;@/store.js&quot;;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;button @click=&quot;globalState.count++&quot;&gt;增加&lt;/button&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">// 组件 B</span><br><span class="line">&lt;script setup&gt;</span><br><span class="line">import &#123; globalState &#125; from &quot;@/store.js&quot;;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;p&gt;当前值：&#123;&#123; globalState.count &#125;&#125;&lt;/p&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure></li>
<li>defineExpose 父组件访问子组件方法<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">// 子组件</span><br><span class="line">&lt;script setup&gt;</span><br><span class="line">import &#123; ref &#125; from &quot;vue&quot;;</span><br><span class="line">const count = ref(0);</span><br><span class="line"></span><br><span class="line">function increment() &#123;</span><br><span class="line">  count.value++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 暴露 `increment` 方法</span><br><span class="line">defineExpose(&#123; increment &#125;);</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">// 父组件</span><br><span class="line">&lt;script setup&gt;</span><br><span class="line">import &#123; ref &#125; from &quot;vue&quot;;</span><br><span class="line">import Child from &quot;./Child.vue&quot;;</span><br><span class="line"></span><br><span class="line">const childRef = ref(null);</span><br><span class="line"></span><br><span class="line">function callChildMethod() &#123;</span><br><span class="line">  childRef.value.increment();</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;Child ref=&quot;childRef&quot; /&gt;</span><br><span class="line">  &lt;button @click=&quot;callChildMethod&quot;&gt;调用子组件方法&lt;/button&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure></li>
<li>mitt 事件总线（兄弟组件传值）<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">// eventBus.js</span><br><span class="line">import mitt from &quot;mitt&quot;;</span><br><span class="line">export const eventBus = mitt();</span><br><span class="line">// 组件 A（发送数据）</span><br><span class="line">&lt;script setup&gt;</span><br><span class="line">import &#123; eventBus &#125; from &quot;@/eventBus.js&quot;;</span><br><span class="line"></span><br><span class="line">function sendData() &#123;</span><br><span class="line">  eventBus.emit(&quot;customEvent&quot;, &quot;Hello from A&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;button @click=&quot;sendData&quot;&gt;发送数据&lt;/button&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">// 组件B （接收数据）</span><br><span class="line">&lt;script setup&gt;</span><br><span class="line">import &#123; onMounted &#125; from &quot;vue&quot;;</span><br><span class="line">import &#123; eventBus &#125; from &quot;@/eventBus.js&quot;;</span><br><span class="line"></span><br><span class="line">onMounted(() =&gt; &#123;</span><br><span class="line">  eventBus.on(&quot;customEvent&quot;, (data) =&gt; &#123;</span><br><span class="line">    console.log(&quot;组件 B 收到：&quot;, data);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>reactive 和 ref 的区别？</p>
<ul>
<li>reactive() 用于对象，内部用 Proxy 实现，ref() 用于基本类型，需要 .value</li>
</ul>
</li>
<li><p>ref 为什么可以用在对象上？</p>
<ul>
<li>Vue3 允许 ref 也能包裹对象，但会自动 转换成 reactive</li>
</ul>
</li>
<li><p>setup() 和 mounted() 的区别？</p>
<ul>
<li>setup() 在 组件创建前beforCreate 执行，不能访问 DOM。</li>
<li>mounted() 在 DOM 挂载后 执行，适合操作 DOM</li>
</ul>
</li>
<li><p>toRef 和 toRefs 是干嘛的？</p>
<ul>
<li>toRef(obj, ‘key’)：创建单个 ref</li>
<li>toRefs(obj)：把整个 reactive 转换成 ref 组成的对象</li>
</ul>
</li>
<li><p>shallowRef 和 shallowReactive 区别？</p>
<ul>
<li>shallowRef() 只让 最外层响应式，内部不监听</li>
<li>shallowReactive() 只让 第一层响应式，深层对象不会变。</li>
</ul>
</li>
</ul>
<h3 id="TypeScript"><a href="#TypeScript" class="headerlink" title="TypeScript"></a>TypeScript</h3><h4 id="Typescript是什么-请简述"><a href="#Typescript是什么-请简述" class="headerlink" title="Typescript是什么 请简述?"></a>Typescript是什么 请简述?</h4><ul>
<li>javascript的强类型版本超集</li>
</ul>
<h4 id="Typescript-与javascript-的优势"><a href="#Typescript-与javascript-的优势" class="headerlink" title="Typescript 与javascript 的优势?"></a>Typescript 与javascript 的优势?</h4><ul>
<li>Typescript优势<ol>
<li>能帮助开发人员检测出错误并修改</li>
<li>TypeScript工具使重构更变的容易、快捷</li>
<li>类型安全能在编码期间检测错误,可以更好的协作,对于大型项目更友好</li>
<li>便于开发人员做注释</li>
</ol>
</li>
<li>javascript优势<ol>
<li>不需要编译,直接由浏览器执行</li>
<li>社区成熟,可以很方便地找到大量成熟的开发项目和可用资源</li>
<li>比较灵活</li>
</ol>
</li>
</ul>
<h3 id="工程化工具"><a href="#工程化工具" class="headerlink" title="工程化工具"></a>工程化工具</h3><h4 id="Webpack"><a href="#Webpack" class="headerlink" title="Webpack"></a>Webpack</h4><ul>
<li>Webpack与gulp区别<ul>
<li>Webpack和另外两个并没有太多的可比性,Gulp&#x2F;Grunt是一种能够优化前端的开发流程的工具,而WebPack是一种模块化的解决方案,不过Webpack的优点使得Webpack在很多场景下可以替代Gulp&#x2F;Grunt类的工具.</li>
</ul>
</li>
<li>请简述webpack中的loaders与plugin的区别<ul>
<li>loader:模块转换器(翻译器),如 less –&gt; css, 如识别 js 结尾的,css 结尾的,图片格式结尾的,通过 loader 转换成相应的文件格式</li>
<li>plugin:扩展插件,如 HtmlWebpackPlugin</li>
</ul>
</li>
<li>说一下webpack的打包原理<ul>
<li>把所有依赖打包成一个bundle.js文件,通过代码分割成单元片段并按需加载.</li>
</ul>
</li>
<li>说一下对websocket的理解<ul>
<li>WebSocket是html5出的一个持久化的协议,它是HTTP协议上的一种补充,因为HTTP协议通信只能由客户端发起,如果要获取一些实时性较高的信息,只能通过“轮询”一类的方式,但是要不停连接所以轮询的效率低,非常浪费资源.所以通过websocket协议可以让服务器主动向客户端推送消息解决了这种问题,做到双向平等对话</li>
</ul>
</li>
</ul>
<h4 id="rollup"><a href="#rollup" class="headerlink" title="rollup"></a>rollup</h4><h4 id="babelrc"><a href="#babelrc" class="headerlink" title="babelrc"></a>babelrc</h4><h4 id="eslint"><a href="#eslint" class="headerlink" title="eslint"></a>eslint</h4><h3 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h3><h4 id="Get和post有什么区别？"><a href="#Get和post有什么区别？" class="headerlink" title="Get和post有什么区别？"></a>Get和post有什么区别？</h4><ol>
<li>get安全性低,post有加密所有安全性高</li>
<li>get发送的数据会暴露在地址栏并且会被保存在历史记录里,而post不会</li>
<li>get参数通过URL传递,post放在Request body中.</li>
<li>传输的数据量不同,get传输的量小,不能大于2kb,post理论上没有限制</li>
<li>get一般用于获取数据,post一般用于发送数据</li>
</ol>
<h4 id="常见的HTTP状态码"><a href="#常见的HTTP状态码" class="headerlink" title="常见的HTTP状态码:"></a>常见的HTTP状态码:</h4><ul>
<li>1##:信息响应类,表示接收到请求并且继续处理<ul>
<li>100  继续.客户端应继续其请求</li>
</ul>
</li>
<li>2##:处理成功响应类,表示动作被成功接收、理解和接受<ul>
<li>200  正常返回数据</li>
</ul>
</li>
<li>3##:重定向响应类,为了完成指定的动作,必须接受进一步处理<ul>
<li>301 Moved Permanently  永久性转移&#x2F;重定向</li>
<li>302 Move Temporarily   临时转移</li>
<li>307 Temporary Redirect 临时重定向,一般应用于服务器的负载均衡</li>
<li>304 Not Modified ——客户端已经执行了GET,但文件未变化</li>
</ul>
</li>
<li>4##:客户端错误,客户请求包含语法错误或者是不能正确执行<ul>
<li>400 Bad Request 请求参数错误</li>
<li>401 Unauthorized 无权限访问</li>
<li>404 Not Found 地址错误</li>
<li>405 Method Not Allowed 当前请求的方式服务器不支持</li>
</ul>
</li>
<li>5##:服务端错误,服务器不能正确执行一个正确的请求<ul>
<li>500 Internal Server Error 未知服务器错误</li>
<li>503 Service Unavailable 服务器超负荷</li>
</ul>
</li>
</ul>
<h4 id="http是什么-有什么特点"><a href="#http是什么-有什么特点" class="headerlink" title="http是什么?有什么特点"></a>http是什么?有什么特点</h4><ul>
<li>http是客户端浏览器或其他程序与Web服务器之间的应用层通信协议</li>
<li>特点:<ol>
<li>简单快速灵活:客户向服务器请求服务时,只需传送请求方法和路径且HTTP允许传输任意类型的数据对象</li>
<li>无连接:每次连接只处理一个请求,收到用户应答后,就断开连接</li>
<li>无状态:协议对于事务处理没有记忆能力,如果后续处理需要前面的信息,则它必须重传</li>
</ol>
</li>
</ul>
<h4 id="HTTP协议和HTTPS区别"><a href="#HTTP协议和HTTPS区别" class="headerlink" title="HTTP协议和HTTPS区别"></a>HTTP协议和HTTPS区别</h4><ol>
<li>传输信息安全性不同;前者是超文本传输协议,信息是明文传输,后者是具有安全性的ssl加密传输协议</li>
<li>连接方式不同:前者很简单是无状态的,后者是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议</li>
<li>端口不同:前者端口是80,后者是443</li>
</ol>
<h4 id="什么是csrf攻击"><a href="#什么是csrf攻击" class="headerlink" title="什么是csrf攻击"></a>什么是csrf攻击</h4><ul>
<li>csrf(cross-site request forgery)是跨站请求伪造;攻击者盗用了用户的身份,以用户的名义发送恶意请求,它可以做的事情包括 以用户的名义发邮件,发消息,购买物品和盗取用户账户</li>
</ul>
<h4 id="为什么会造成跨域-请简述同源策略"><a href="#为什么会造成跨域-请简述同源策略" class="headerlink" title="为什么会造成跨域&#x2F;请简述同源策略"></a>为什么会造成跨域&#x2F;请简述同源策略</h4><ul>
<li>不符合同源协议(不同协议;不同域名&#x2F;IP;不同端口号),</li>
<li>解决方法:<ol>
<li>JSONP请求:JSONP的原理是利用<script>标签的跨域特性,可以不受限制地从其他域中加载资源</li>
<li>CORS跨域:就是使用自定义的HTTP头部让浏览器与服务器进行沟通,从而决定请求或响应是应该成功还是应该失败.</li>
<li>Web sockets跨域:是HTML5一种新的协议.它实现了浏览器与服务器全双工通信,同时允许跨域通讯,在js中创建WebSockets后,会有一个HTTP请求发送到浏览器以发起连接.在取得服务器响应后,建立的连接会使用HTTP升级从HTTP协议交换为WebSocket协议,所以只能支持此协议的专门服务器才能正常工作</li>
<li>proxy代理:请求不会直接发给目标主机,而是先发给代理机再向目标主机发送,接收目标机数据后再由代理服务器返还给用户</li>
</ol>
</li>
</ul>
<h4 id="什么是CORS"><a href="#什么是CORS" class="headerlink" title="什么是CORS"></a>什么是CORS</h4><ul>
<li>CORS是一个W3C标准,全称是"跨域资源共享"(Cross-Origin Resource Sharing).它允许浏览器向跨源服务器,发出XMLHttpRequest请求,从而克服了ajax只能同源使用的限制.</li>
</ul>
<h4 id="后台传递过来的数据格式有哪些"><a href="#后台传递过来的数据格式有哪些" class="headerlink" title="后台传递过来的数据格式有哪些"></a>后台传递过来的数据格式有哪些</h4><ol>
<li>json:一段用数组或对象表示得键值对</li>
<li>arraybuffer: 通用的、固定长度的原始二进制数据缓冲区,它是一个字节数组</li>
<li>blob : 一个不可变、原始数据的类文件对象.它的数据可以按文本或二进制的格式进行读取</li>
<li>document : 如xml一类的文件格式</li>
<li>text : 文本格式</li>
<li>stream : 数据流</li>
</ol>
<h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><h4 id="数组去重的方式"><a href="#数组去重的方式" class="headerlink" title="数组去重的方式"></a>数组去重的方式</h4><ol>
<li>双层for循环  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">unique</span>(<span class="params">arr</span>)&#123;            </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;arr.<span class="property">length</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j = i+ <span class="number">1</span>; j &lt; arr.<span class="property">length</span>; j++)&#123;</span><br><span class="line">          <span class="keyword">if</span>(arr[i]==arr[j])&#123;<span class="comment">//第一个等同于第二个,splice方法删除第二个</span></span><br><span class="line">                arr.<span class="title function_">splice</span>(j,<span class="number">1</span>); j--;<span class="comment">//删除后需要让j的位置回退一个,不然会跳过一个数</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>利用indexOf去重  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">unique</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> array = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (array.<span class="title function_">indexOf</span>(arr[i]) === -<span class="number">1</span>) &#123;</span><br><span class="line">            array.<span class="title function_">push</span>(arr[i])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>利用filter过滤  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">unique</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> arr.<span class="title function_">filter</span>(<span class="keyword">function</span>(<span class="params">item, index, arr</span>) &#123;</span><br><span class="line">        <span class="comment">//如果当前元素在原始数组的第一个索引==当前循环索引,返回当前元素,不然就过滤掉</span></span><br><span class="line">        <span class="keyword">return</span> arr.<span class="title function_">indexOf</span>(item,<span class="number">0</span>) === index;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>利用ES6 Set去重  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">unique</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Array</span>.<span class="title function_">from</span>(<span class="keyword">new</span> <span class="title class_">Set</span>(arr))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="数组排序的方式"><a href="#数组排序的方式" class="headerlink" title="数组排序的方式"></a>数组排序的方式</h4><ol>
<li>冒泡排序  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sort</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> temp = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>;i &lt; arr.<span class="property">length</span>-<span class="number">1</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j = <span class="number">0</span>;j &lt; arr.<span class="property">length</span>-i-<span class="number">1</span> ;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[j] &gt; arr[j+<span class="number">1</span>])&#123;</span><br><span class="line">                temp =  arr[j];</span><br><span class="line">                arr[j] = arr[j+<span class="number">1</span>];</span><br><span class="line">                arr[j+<span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>擂台排序  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sort</span>(<span class="params">arr</span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> temp = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i =<span class="number">0</span>;i &lt; arr.<span class="property">length</span> - <span class="number">1</span> ; i++ )&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j = i+ <span class="number">1</span> ;j &lt; arr.<span class="property">length</span> ; j++ )&#123;    </span><br><span class="line">            <span class="keyword">if</span>(arr[i] &gt; arr[j])&#123;</span><br><span class="line">                temp = arr[i];</span><br><span class="line">                arr[i] = arr[j];</span><br><span class="line">                arr[j] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>sort排序  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sort</span>(<span class="params">arr</span>)&#123;</span><br><span class="line">    arr.<span class="title function_">sort</span>(<span class="function">(<span class="params">small,big</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> small-big;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="遍历一个多维数组"><a href="#遍历一个多维数组" class="headerlink" title="遍历一个多维数组"></a>遍历一个多维数组</h4>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">each</span>(<span class="params">obj</span>)&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">in</span> obj)&#123;</span><br><span class="line">    <span class="title function_">typeof</span>(obj[key]) == <span class="string">&quot;object&quot;</span> ? <span class="title function_">each</span>(obj[key]) : <span class="variable language_">console</span>.<span class="title function_">log</span>(key+<span class="string">&#x27;--&#x27;</span>+obj[key])</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="深拷贝的代码实现"><a href="#深拷贝的代码实现" class="headerlink" title="深拷贝的代码实现"></a>深拷贝的代码实现</h4><ul>
<li>简单深拷贝(一层拷贝)<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">deepCopy</span>(<span class="params">obj</span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> copyObj = <span class="title class_">Array</span>.<span class="title function_">isArray</span>(obj) ? [] : &#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">in</span> obj)&#123;</span><br><span class="line">        copyObj[key] = obj[key];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> copyObj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>复杂深拷贝(递归实现多层拷贝)<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">deepCopy</span>(<span class="params">obj</span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> copyObj = <span class="title class_">Array</span>.<span class="title function_">isArray</span>(obj) ? [] : &#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">in</span> obj)&#123;</span><br><span class="line">        <span class="keyword">if</span>( obj.<span class="title function_">hasOwnProperty</span>(key) )&#123;</span><br><span class="line">            copyObj[key] = <span class="keyword">typeof</span> obj[key] === <span class="string">&#x27;object&#x27;</span> ? <span class="title function_">deepCopy</span>(obj[key]) : obj[key] ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> copyObj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</div><script src="https://jsd.onmicrosoft.cn/npm/hexo-theme-a4@latest/source/js/lightgallery.min.js"></script><script>if("undefined"!=typeof lightGallery) {
        var options1 = {
            selector: '.gallery-item'
        };
        lightGallery(document.getElementsByClassName('.article-gallery')[0], options1);
        }</script>
    </div>

    <div class="post-meta">
        <i>
        
            <span>2024-04-01</span>
            
                <span>该篇文章被 Andrew</span>
            
            
                <span>打上标签:
                    
                    
                        <a href='/tags/%E5%89%8D%E7%AB%AF/'>
                            前端
                        </a>
                    
                        <a href='/tags/%E6%A6%82%E5%BF%B5/'>
                            概念
                        </a>
                    
                </span>
             
             
                <span>归为分类:
                    
                    
                        <a href='/categories/%E6%8A%80%E6%9C%AF/'>
                            技术
                        </a>
                    
                </span>
            
        
        </i>
    </div>
    <br>
    
    <!-- <div class="post-footer-pre-next">
        <span>上一篇：<a href=""></a></span>
        <span class="post-footer-pre-next-last-span-right">上一篇：<a href=""></a></span>
    </div> -->

    
        

     
</div>



                                      
                    
                    
                    <div class="footer">
    
        <span> 
            © 2023-2024 

            
                

            
        </span>
    
</div>
<!--这是指一条线往下的内容-->
<div class="footer-last">
    
            <span>永远相信美好的事情即将发生</span>
            
                <span class="footer-last-span-right"><i>本站由<a target="_blank" rel="noopener" href="https://hexo.io/zh-cn/index.html">Hexo</a>驱动｜使用<a target="_blank" rel="noopener" href="https://github.com/HiNinoJay/hexo-theme-A4">Hexo-theme-A4</a>主题</i></span>
            
    
</div>


    
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.0/jquery.min.js"></script>

    <!--目录-->
    
        <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/1.7.2/jquery.min.js" type="text/javascript" ></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/jqueryui/1.12.1/jquery-ui.min.js" type="text/javascript" ></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery.tocify/1.9.0/javascripts/jquery.tocify.min.js" type="text/javascript" ></script>
        
<script src="/js/toc.js"></script>

    

    
<script src="/js/randomHeaderContent.js"></script>

    <!--回到顶部按钮-->
    
        
<script src="/js/returnToTop.js"></script>

    

    
        
<script src="/js/returnToLastPage.js"></script>

    





<script src="/js/lightgallery.min.js"></script>



                </div>
            
            
                <!-- 回到顶部的按钮-->  
                <div class="progress-wrap shadow-drop-2-bottom">
                    <svg class="progress-circle svg-content" width="100%" height="100%" viewBox="-1 -1 102 102">
                        <path d="M50,1 a49,49 0 0,1 0,98 a49,49 0 0,1 0,-98"/>
                    </svg>
                </div>
            
            
                <!-- 返回的按钮-->  
                <div class="return-to-last-progress-wrap shadow-drop-2-bottom">
                    <svg class="progress-circle svg-content" width="100%" height="100%" viewBox="-1 -1 102 102">
                        <path d="M50,1 a49,49 0 0,1 0,98 a49,49 0 0,1 0,-98"/>
                    </svg>
                </div>
            
    </body>
</html>