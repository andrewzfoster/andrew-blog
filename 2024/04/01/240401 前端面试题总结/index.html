<!DOCTYPE html>
<html lang="zh-CN">
    
    <head>
    <meta charset="utf-8">
    <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover" name="viewport" />
    <meta name="description" content="前端面试题总结" />
    <meta name="hexo-theme-A4" content="v1.9.0" />
    <link rel="alternate icon" type="image/webp" href="/img/favicon.webp">
    <title>Andrew&#39;s Home</title>

    
        
<link rel="stylesheet" href="/css/highlight/style1.css">

        
<link rel="stylesheet" href="/css/reset.css">

        
<link rel="stylesheet" href="/css/markdown.css">

        
<link rel="stylesheet" href="/css/fonts.css">
 
         <!--注意：首页既不是post也不是page-->
        
        
        
<link rel="stylesheet" href="/css/ui.css">
 
        
<link rel="stylesheet" href="/css/style.css">


        
            <!--返回顶部css-->
            
<link rel="stylesheet" href="/css/returnToTop.css">

            
<link rel="stylesheet" href="/css/unicons.css">

        
        
            <!--目录-->
            
<link rel="stylesheet" href="/css/toc.css">

        
    

    
        
<link rel="stylesheet" href="/css/returnToLastPage.css">

    
    
   
<link rel="stylesheet" href="/css/lightgallery.min.css">


<meta name="generator" content="Hexo 7.1.1"></head>
    
    
    
    <body>
        <script src="/js/darkmode-js.min.js"></script>
        
        <script>
            const dkOptions = {
                bottom: '53px', // default: '32px'
                right: 'unset', // default: '32px'
                left: '42px', // default: 'unset'
                time: '0.3s', // default: '0.3s'
                mixColor: '#fff', // default: '#fff'
                backgroundColor: ' #e4e4e4 ',  // default: '#fff'
                buttonColorDark: '#100f2c',  // default: '#100f2c'
                buttonColorLight: '#fff', // default: '#fff'
                saveInCookies: true, // default: true,
                label: '🌓', // default: ''
                autoMatchOsTheme: true // default: true
            }
            const darkmode = new Darkmode(dkOptions);
            darkmode.showWidget();
        </script>
        
        
            <div class="left-toc-container">
                <nav id="toc" class="bs-docs-sidebar"></nav>
            </div>
        
        <div class="paper">
            
            
            
            
                <div class="shadow-drop-2-bottom paper-main">
                    


<div class="header">
    <div class="header-container">
        <img style="
        width: 56px;
        height: auto;border-radius: 6px;" alt="^-^" cache-control="max-age=86400" class="header-img" src="/img/favicon.webp" width="10%"></img>
        <div class="header-content">
            <a class="logo" href="/">Andrew</a> 
            <span class="description"></span> 
        </div>
        
    </div>
    
   
    <ul class="nav">
        
            
                <li><a href="/">首页</a></li>
            
        
            
                <li><a href="/list/">文章</a></li>
            
        
            
                <li><a href="/categories/">分类</a></li>
            
        
            
                <li><a href="/project/">作品</a></li>
            
        
            
                <li><a href="/message/">留言</a></li>
            
        
            
                <li><a href="/about/">关于</a></li>
            
        
    </ul>
</div> 
        
                    
                    

                    
                    
                    
                    <!--说明是文章post页面-->
                    
                        <div class="post-main">

    
        <div class="post-main-title">
            前端面试题总结
        </div>
      
    

    <div class="post-md">
        
            
                <ol class="post-toc"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93"><span class="post-toc-text">前端面试题总结</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="post-toc-text">数据类型</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B"><span class="post-toc-text">基本类型</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B"><span class="post-toc-text">引用类型</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E7%B1%BB%E5%9E%8B%E5%88%A4%E6%96%AD"><span class="post-toc-text">类型判断</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#Map-Set"><span class="post-toc-text">Map &amp; Set</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E6%95%B0%E7%BB%84-%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="post-toc-text">数组&#x2F;字符串</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E6%95%B0%E7%BB%84%E6%93%8D%E4%BD%9C%E6%96%B9%E6%B3%95"><span class="post-toc-text">数组操作方法</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%93%8D%E4%BD%9C%E6%96%B9%E6%B3%95"><span class="post-toc-text">字符串操作方法</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E6%95%B0%E7%BB%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%93%8D%E4%BD%9C%E9%A2%98"><span class="post-toc-text">数组字符串操作题</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E6%AD%A3%E5%88%99"><span class="post-toc-text">正则</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E6%AD%A3%E5%88%99%E4%B8%AD%E7%9A%84%E7%89%B9%E6%AE%8A%E5%AD%97%E7%AC%A6"><span class="post-toc-text">正则中的特殊字符:</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E5%87%BD%E6%95%B0"><span class="post-toc-text">函数</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E6%99%AE%E9%80%9A%E5%87%BD%E6%95%B0"><span class="post-toc-text">普通函数</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#function-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="post-toc-text">function 构造函数</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#class-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0-%E6%9C%AC%E8%B4%A8%E4%BB%8D%E7%84%B6%E6%98%AF-function-%E7%9A%84%E8%AF%AD%E6%B3%95%E7%B3%96"><span class="post-toc-text">class 构造函数(本质仍然是 function 的语法糖)</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#bind-%E5%92%8C-call-%E4%B8%8E-apply-%E5%8C%BA%E5%88%AB"><span class="post-toc-text">bind()和 call()与 apply()区别:</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8-API"><span class="post-toc-text">浏览器 API</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#ajax-%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E5%92%8C%E4%BD%BF%E7%94%A8"><span class="post-toc-text">ajax 如何创建和使用</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8%E4%B8%8E-Cookie-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="post-toc-text">本地存储与 Cookie 的区别</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#Json-%E5%A6%82%E4%BD%95%E6%96%B0%E5%A2%9E-%E5%88%A0%E9%99%A4%E9%94%AE%E5%80%BC%E5%AF%B9"><span class="post-toc-text">Json 如何新增&#x2F;删除键值对</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#ES6-%E6%96%B0%E7%89%B9%E6%80%A7"><span class="post-toc-text">ES6 新特性</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5"><span class="post-toc-text">核心概念</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E9%97%AD%E5%8C%85"><span class="post-toc-text">闭包</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2"><span class="post-toc-text">什么是内存泄露?</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E5%8E%9F%E5%9E%8B-%E5%8E%9F%E5%9E%8B%E9%93%BE-%E7%BB%A7%E6%89%BF"><span class="post-toc-text">原型&#x2F;原型链&#x2F;继承</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E5%90%8C%E6%AD%A5%E4%B8%8E%E5%BC%82%E6%AD%A5%E7%9A%84%E5%8C%BA%E5%88%AB-%E9%98%BB%E5%A1%9E%E4%B8%8E%E9%9D%9E%E9%98%BB%E5%A1%9E%E5%8C%BA%E5%88%AB"><span class="post-toc-text">同步与异步的区别&#x2F;阻塞与非阻塞区别</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E8%AF%B7%E7%AE%80%E8%BF%B0-async-%E7%9A%84%E7%94%A8%E6%B3%95"><span class="post-toc-text">请简述 async 的用法</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-JSONP-%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88"><span class="post-toc-text">什么是 JSONP 工作原理是什么?</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98%E6%98%AF%E4%BB%80%E4%B9%88-%E5%A6%82%E4%BD%95%E7%A1%AE%E5%AE%9A%E4%BA%8B%E4%BB%B6%E6%BA%90"><span class="post-toc-text">事件委托是什么?如何确定事件源</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#This-%E6%8C%87%E5%90%91"><span class="post-toc-text">This 指向</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E4%B8%8E%E6%99%AE%E9%80%9A%E5%87%BD%E6%95%B0%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="post-toc-text">箭头函数与普通函数的区别</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E6%99%AE%E9%80%9A%E5%87%BD%E6%95%B0%E5%92%8C%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="post-toc-text">普通函数和构造函数的区别</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AF%B7%E7%AE%80%E8%BF%B0"><span class="post-toc-text">什么是面向对象请简述</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E9%87%8D%E7%BB%98%E4%BB%A5%E5%8F%8A%E5%9B%9E%E6%B5%81%E6%98%AF%E4%BB%80%E4%B9%88"><span class="post-toc-text">重绘以及回流是什么</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF"><span class="post-toc-text">事件循环</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D"><span class="post-toc-text">深浅拷贝</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#Promise"><span class="post-toc-text">Promise</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E5%87%BD%E6%95%B0%E8%8A%82%E6%B5%81%E5%92%8C%E9%98%B2%E6%8A%96"><span class="post-toc-text">函数节流和防抖</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#VUE"><span class="post-toc-text">VUE</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#VUE2"><span class="post-toc-text">VUE2</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#VUE3"><span class="post-toc-text">VUE3</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#TypeScript"><span class="post-toc-text">TypeScript</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#Typescript-%E6%98%AF%E4%BB%80%E4%B9%88-%E8%AF%B7%E7%AE%80%E8%BF%B0"><span class="post-toc-text">Typescript 是什么 请简述?</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#Typescript-%E4%B8%8E-javascript-%E7%9A%84%E4%BC%98%E5%8A%BF"><span class="post-toc-text">Typescript 与 javascript 的优势?</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E5%B7%A5%E7%A8%8B%E5%8C%96%E5%B7%A5%E5%85%B7"><span class="post-toc-text">工程化工具</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#Webpack"><span class="post-toc-text">Webpack</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#Vite"><span class="post-toc-text">Vite</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#rollup"><span class="post-toc-text">rollup</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#babelrc"><span class="post-toc-text">babelrc</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#eslint"><span class="post-toc-text">eslint</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E7%BD%91%E7%BB%9C"><span class="post-toc-text">网络</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#Get-%E5%92%8C-post-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="post-toc-text">Get 和 post 有什么区别？</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84-HTTP-%E7%8A%B6%E6%80%81%E7%A0%81"><span class="post-toc-text">常见的 HTTP 状态码:</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#http-%E6%98%AF%E4%BB%80%E4%B9%88-%E6%9C%89%E4%BB%80%E4%B9%88%E7%89%B9%E7%82%B9"><span class="post-toc-text">http 是什么?有什么特点</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#HTTP-%E5%8D%8F%E8%AE%AE%E5%92%8C-HTTPS-%E5%8C%BA%E5%88%AB"><span class="post-toc-text">HTTP 协议和 HTTPS 区别</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-csrf-%E6%94%BB%E5%87%BB"><span class="post-toc-text">什么是 csrf 攻击</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E9%80%A0%E6%88%90%E8%B7%A8%E5%9F%9F-%E8%AF%B7%E7%AE%80%E8%BF%B0%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5"><span class="post-toc-text">为什么会造成跨域&#x2F;请简述同源策略</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-CORS"><span class="post-toc-text">什么是 CORS</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E5%90%8E%E5%8F%B0%E4%BC%A0%E9%80%92%E8%BF%87%E6%9D%A5%E7%9A%84%E6%95%B0%E6%8D%AE%E6%A0%BC%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="post-toc-text">后台传递过来的数据格式有哪些</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E7%AE%97%E6%B3%95%E9%A2%98"><span class="post-toc-text">算法题</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="post-toc-text">数组去重的方式</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E6%95%B0%E7%BB%84%E6%8E%92%E5%BA%8F%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="post-toc-text">数组排序的方式</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E9%81%8D%E5%8E%86%E4%B8%80%E4%B8%AA%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84"><span class="post-toc-text">遍历一个多维数组</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E6%B7%B1%E6%8B%B7%E8%B4%9D%E7%9A%84%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="post-toc-text">深拷贝的代码实现</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84"><span class="post-toc-text">合并两个有序数组</span></a></li></ol></li></ol></li></ol>
            
        
        <link rel="stylesheet" type="text/css" href="https://jsd.onmicrosoft.cn/npm/hexo-theme-a4@latest/source/css/lightgallery.min.css" /><div class=".article-gallery"><h2 id="前端面试题总结"><a href="#前端面试题总结" class="headerlink" title="前端面试题总结"></a>前端面试题总结</h2><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><h4 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h4><ul>
<li>string ‘字符串’</li>
<li>number ‘64 位双精度浮点型数字’(包含 NaN)</li>
<li>boolean ‘布尔’,</li>
<li>undefined ‘没有任何值’</li>
<li>null ‘没有任何对象’</li>
<li>bigint ‘任意精度格式的整数’</li>
<li>symbol ‘标记值’</li>
</ul>
<h4 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h4><ul>
<li>对象’object’(Function 也是一个特殊的对象)</li>
</ul>
<h4 id="类型判断"><a href="#类型判断" class="headerlink" title="类型判断"></a>类型判断</h4><ul>
<li>如何判断一个数据是 NaN<ul>
<li>用全等判断 x &#x3D;&#x3D;&#x3D; NaN;</li>
<li>用 isNaN(x) 来判断;</li>
</ul>
</li>
<li>null 与 undefined 区别<ul>
<li>null 表示一个值被定义了,定义为“空值”;</li>
<li>undefined 表示根本不存在定义;</li>
</ul>
</li>
<li>typeof 和 istanceof 区别?<ul>
<li>typeof 会返回一个运算数的基本类型</li>
<li>instanceof 判断一个对象是否是某个构造函数的实例<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;&#125;</span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p <span class="keyword">instanceof</span> <span class="title class_">Person</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>如何判断一个对象是对象<ul>
<li>Object.prototype.toString.call({}) &#x2F;&#x2F; “[object Object]”</li>
</ul>
</li>
<li>如何判断一个对象时数组<ul>
<li>Object.prototype.toString.call([]) &#x2F;&#x2F; “[object Array]”</li>
<li>Array.isArray([])</li>
<li>[] instanceof Array &#x2F;&#x2F; true</li>
</ul>
</li>
</ul>
<h4 id="Map-Set"><a href="#Map-Set" class="headerlink" title="Map &amp; Set"></a>Map &amp; Set</h4><ul>
<li><p>概念</p>
<ul>
<li>Map:主要用于存储和管理键值对数据,适合在需要快速查找、插入和删除键值对的场景中使用.常见应用包括缓存、配置管理和数据关联.</li>
<li>Set:主要用于存储唯一值集合,适合在需要确保元素不重复的场景中使用.常见应用包括去重、集合操作和存在性检查.</li>
</ul>
</li>
<li><p>用途</p>
<ul>
<li><p>Map:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">map.<span class="title function_">set</span>(<span class="string">&quot;a&quot;</span>, <span class="number">1</span>); <span class="comment">// 向 Map 添加或更新一个键值对.</span></span><br><span class="line">map.<span class="title function_">set</span>(<span class="string">&quot;b&quot;</span>, <span class="number">2</span>);</span><br><span class="line">map.<span class="title function_">set</span>(<span class="string">&quot;c&quot;</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(map.<span class="title function_">get</span>(<span class="string">&quot;a&quot;</span>)); <span class="comment">// 获取对应键的值</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(map.<span class="title function_">has</span>(<span class="string">&quot;b&quot;</span>)); <span class="comment">// 检查 Map 是否包含某个键.</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(map.<span class="property">size</span>); <span class="comment">// 返回 Map 中的键值对数量.</span></span><br><span class="line"></span><br><span class="line">map.<span class="title function_">delete</span>(<span class="string">&quot;c&quot;</span>); <span class="comment">// 删除键值对.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> map) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;key&#125;</span>: <span class="subst">$&#123;value&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br><span class="line">map.<span class="title function_">clear</span>(); <span class="comment">//   清空 Map</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>Set:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> set = <span class="keyword">new</span> <span class="title class_">Set</span>();</span><br><span class="line">set.<span class="title function_">add</span>(<span class="number">1</span>); <span class="comment">// 向 Set 添加一个新值</span></span><br><span class="line">set.<span class="title function_">add</span>(<span class="number">2</span>);</span><br><span class="line">set.<span class="title function_">add</span>(<span class="number">3</span>);</span><br><span class="line">set.<span class="title function_">add</span>(<span class="number">1</span>); <span class="comment">// 不会重复添加,每个值都是唯一的,重复的值会被忽略.</span></span><br><span class="line">set.<span class="title function_">delete</span>(<span class="number">3</span>); <span class="comment">// 从 Set 中删除一个值.</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(set.<span class="title function_">has</span>(<span class="number">1</span>)); <span class="comment">// 检查 Set 中是否存在某个值.</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(set.<span class="property">size</span>); <span class="comment">// 返回 Set 中的值的数量.</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> set) &#123;</span><br><span class="line">  <span class="comment">// 可以用for of 遍历</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(value);</span><br><span class="line">&#125;</span><br><span class="line">set.<span class="title function_">clear</span>(); <span class="comment">//  清空 Set</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="数组-字符串"><a href="#数组-字符串" class="headerlink" title="数组&#x2F;字符串"></a>数组&#x2F;字符串</h3><h4 id="数组操作方法"><a href="#数组操作方法" class="headerlink" title="数组操作方法"></a>数组操作方法</h4><ul>
<li>arr.push() 从后添,返回值为添加完后的数组的长度</li>
<li>arr.pop() 从后删一个,返回值是删除的元素</li>
<li>arr.unshift() 从前添,返回值是添加后数组的长度</li>
<li>arr.shift() 从前删一个,返回值是删除的元素</li>
<li>arr.splice(i,n)从数组中添加&#x2F;删除&#x2F;修改值,返回值被改动的值</li>
<li>arr.concat()  连接两个数组 返回值为连接后的新数组</li>
<li>arr.sort()  将数组进行排序,返回值是排好的数组,默认是按照最左边的数字进行排序,不是按照数字大小排序的</li>
<li>arr.reverse()  将数组反转,返回值是反转后的数组</li>
<li>arr.slice(start,end)  切一段从索引值 start 到 end(不包含)的数组,返回值是切出来的数组</li>
<li>arr.join(separator) 把数组的所有元素放入一个字符串,方法内的参数作为分隔符,省略该参数,则使用逗号作为分隔符</li>
<li>arr.forEach(callback)  遍历数组,无 return   即使有 return,也不会返回任何值,并且会影响原来的数组</li>
<li>arr.map(callback)  映射数组(遍历数组),有 return 返回一个新数组</li>
<li>arr.filter(callback)  过滤数组,返回一个满足要求的数组</li>
<li>arr.indxOf() : 返回数组中满足提供的测试函数的第一个元素的下标</li>
<li>arr.lastIndexOf() : 从后往前返回数组中满足提供的测试函数的第一个元素的下标</li>
<li>arr.find() : 返回数组中满足提供的测试函数的第一个元素的值</li>
<li>arr.some() : 测试数组中是否至少有一个元素通过了由提供的函数实现的测试( 一个直则真 )</li>
<li>arr.every() : 测试一个数组内的所有元素是否都能通过指定函数的测试( 全真才真 )</li>
<li>map,forEach 和 for 循环区别:<ul>
<li>forEach 只是进行简单的数组遍历,无返回值,且 break 和 return 语句不能跳出循环,for 可以适用于更复杂的循环且效率更高</li>
<li>map 代表是映射它有返回值,返回值是一个处理过后的新数组且不改变原数组</li>
</ul>
</li>
</ul>
<h4 id="字符串操作方法"><a href="#字符串操作方法" class="headerlink" title="字符串操作方法"></a>字符串操作方法</h4><ul>
<li>str.charAt(index) 返回在指定位置的字符</li>
<li>str.concat(stringA,stringB,…,stringZ) 连接两个或多个字符串,返回连接后的字符串</li>
<li>str.indexOf(检索的字符串,开始检索的位置【可省略】)检索字符串返回某个指定的字符串值在字符串中首次出现的位置,如果没有返回+1</li>
<li>str.lastIndexOf(检索的字符串,开始检索的位置【可省略】) 从后向前搜索字符串,返回一个指定的字符串值最后出现的位置,如果没有返+1</li>
<li>str.replace(正则表达式&#x2F;检索的字符串,替换成的字符串)在字符串中用一些字符替换另一些字符,或替换一个与正则表达式匹配的子串.</li>
<li>str.slice(起始下标【slice 独有:可为负数,+1 指字符串的最后一个字符】,结尾的下标【可省略,如果省略则代表一直到字符串结尾】) 提取字符串的片断,返回被提取的部分.从 start 开始到 end 结束(不包括结尾的下标所代表的值)</li>
<li>str.substr(起始下标,长度【可选】) 返回从起始索引号提取字符串中指定数目的字符.</li>
<li>str.substring(起始下标,结束的下标【可选】) 返回提取字符串中两个指定的索引号之间的字符.</li>
<li>str.split(字符串或正则表达式,从该参数指定的地方分割,多少个【可选】) 把字符串分割为字符串数组.</li>
</ul>
<h4 id="数组字符串操作题"><a href="#数组字符串操作题" class="headerlink" title="数组字符串操作题"></a>数组字符串操作题</h4><ul>
<li><p>反转一个字符串中的每个单词，但保持单词顺序</p>
<blockquote>
<p>输入：”Hello World”<br>输出：”olleH dlroW”</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;Hello World&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> arr = str.<span class="title function_">split</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line"><span class="keyword">let</span> arr1 = arr[<span class="number">0</span>].<span class="title function_">split</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> arr2 = arr[<span class="number">1</span>].<span class="title function_">split</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">arr1.<span class="title function_">reverse</span>();</span><br><span class="line">arr2.<span class="title function_">reverse</span>();</span><br><span class="line"><span class="keyword">let</span> reverseStr = arr1.<span class="title function_">join</span>(<span class="string">&quot;&quot;</span>) + <span class="string">&quot; &quot;</span> + arr2.<span class="title function_">join</span>(<span class="string">&quot;&quot;</span>);</span><br></pre></td></tr></table></figure></li>
<li><p>取出字符串中的所有数字，并转换为数组</p>
<blockquote>
<p>输入：”a1b2c3d4”<br>输出：[1, 2, 3, 4]</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> data = <span class="string">&quot;a1b2c3d4&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> arr = data.<span class="title function_">match</span>(<span class="regexp">/\d/g</span>).<span class="title function_">map</span>(<span class="title class_">Number</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>将一个句子中的单词按长度排序，长度相同的按字母顺序排序</p>
<blockquote>
<p>输入：”Vue is a progressive framework”<br>输出：[“a”, “is”, “Vue”, “framework”, “progressive”]</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> data = [<span class="string">&quot;a&quot;</span>, <span class="string">&quot;is&quot;</span>, <span class="string">&quot;Vue&quot;</span>, <span class="string">&quot;framework&quot;</span>, <span class="string">&quot;progressive&quot;</span>];</span><br><span class="line">data.<span class="title function_">split</span>(<span class="string">&quot; &quot;</span>).<span class="title function_">sort</span>(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a.<span class="property">length</span> - b.<span class="property">length</span> || a.<span class="title function_">localeCompare</span>(b));</span><br></pre></td></tr></table></figure>
</li>
<li><p>找出数组中最长的字符串（如果有多个相同长度的，返回第一个）</p>
<blockquote>
<p>输入：[“short”, “medium”, “longest”, “tiny”]<br>输出：”longest”</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> data = [<span class="string">&quot;short&quot;</span>, <span class="string">&quot;medium&quot;</span>, <span class="string">&quot;longest&quot;</span>, <span class="string">&quot;tiny&quot;</span>];</span><br><span class="line"><span class="comment">// longest 是传入的数据</span></span><br><span class="line">data.<span class="title function_">reduce</span>(</span><br><span class="line">  <span class="function">(<span class="params">longest, word</span>) =&gt;</span> (word.<span class="property">length</span> &gt; longest.<span class="property">length</span> ? word : longest),</span><br><span class="line">  <span class="string">&quot;&quot;</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="正则"><a href="#正则" class="headerlink" title="正则"></a>正则</h3><h4 id="正则中的特殊字符"><a href="#正则中的特殊字符" class="headerlink" title="正则中的特殊字符:"></a>正则中的特殊字符:</h4><ul>
<li>单个字符:<ul>
<li>^ :正则开始</li>
<li>$  :正则结束</li>
<li>.  :元字符, 表示任意一个字符</li>
<li>\ :表示转义字符         如:.表示.</li>
<li>- :表示其前面紧挨着的字符至少出现 1 次 等价{1,}</li>
<li>* :表示其前面出现的字符至少出现过 0 次   等价{0,}</li>
<li>?  :表示其前面出现的字符至少出现过 0 次，至多 1 次   等价{0,1}</li>
<li>| :表示或者</li>
</ul>
</li>
<li>组合字符:<ul>
<li>\d :0-9 之间的任意一个数字 \d 只占一个位置</li>
<li>\D :除了\d</li>
<li>\w :数字，字母 ，下划线 0-9 a-z A-Z _</li>
<li>\W :除了\w</li>
<li>\s :空格或者空白等</li>
<li>\S :除了\s</li>
</ul>
</li>
</ul>
<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><h4 id="普通函数"><a href="#普通函数" class="headerlink" title="普通函数"></a>普通函数</h4><ul>
<li><p>回调函数：是一个作为参数传递给另一个函数的函数</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 模块A</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getData</span>(<span class="params">callBack</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> status = <span class="number">404</span>;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    status = <span class="number">200</span>;</span><br><span class="line">    <span class="title function_">callBack</span>(status);</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">getData</span>(dealData); <span class="comment">// 模块B传入模块A</span></span><br><span class="line"><span class="comment">// 模块B</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">dealData</span>(<span class="params">num</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;i get the number:&quot;</span> + num);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>arguments 用法：是 JavaScript 函数内部的一个 类数组对象(array-like object)，用于存储所有传入函数的参数。它只可以在 非箭头函数 中使用</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">test</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">arguments</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">arguments</span>[<span class="number">0</span>]); <span class="comment">// 第一个参数</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">arguments</span>[<span class="number">1</span>]); <span class="comment">// 第二个参数</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">arguments</span>.<span class="property">length</span>); <span class="comment">// 参数个数</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> args = [...<span class="variable language_">arguments</span>]; <span class="comment">// 用扩展运算符转换为数组</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(args);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">test</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"><span class="comment">// 输出：Arguments(3) [1, 2, 3, callee: ƒ, Symbol(Symbol.iterator): ƒ]</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="function-构造函数"><a href="#function-构造函数" class="headerlink" title="function 构造函数"></a>function 构造函数</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">People</span>(<span class="params">name, sex</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">sex</span> = sex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">People</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayName</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="class-构造函数-本质仍然是-function-的语法糖"><a href="#class-构造函数-本质仍然是-function-的语法糖" class="headerlink" title="class 构造函数(本质仍然是 function 的语法糖)"></a>class 构造函数(本质仍然是 function 的语法糖)</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name, sex</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">sex</span> = sex;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">sayName</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Superman</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Person</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name, sex, skill</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(name, sex);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">skill</span> = skill;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">useSkill</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">skill</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="bind-和-call-与-apply-区别"><a href="#bind-和-call-与-apply-区别" class="headerlink" title="bind()和 call()与 apply()区别:"></a>bind()和 call()与 apply()区别:</h4><ul>
<li>call 和 apply 主要用于 改变 this 指向，它们可以让一个对象借用另一个对象的方法。它们的主要区别在于 参数传递的方式不同。</li>
<li>bind 也是改变 this 的方法，但它不会立即执行函数，而是返回一个新的函数：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// func.call(thisArg, arg1, arg2, ...);</span></span><br><span class="line"><span class="keyword">const</span> person1 = &#123; <span class="attr">name</span>: <span class="string">&quot;Alice&quot;</span> &#125;;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sayHello</span>(<span class="params">age</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Hello, my name is <span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span> and I am <span class="subst">$&#123;age&#125;</span> years old.`</span>);</span><br><span class="line">&#125;</span><br><span class="line">sayHello.<span class="title function_">call</span>(person1, <span class="number">25</span>); <span class="comment">// Hello, my name is Alice and I am 25 years old.</span></span><br><span class="line"><span class="comment">// func.apply(thisArg, [arg1, arg2, ...]); 参数必须用数组传递！</span></span><br><span class="line">sayHello.<span class="title function_">apply</span>(person1, [<span class="number">25</span>]); <span class="comment">// Hello, my name is Alice and I am 25 years old.</span></span><br><span class="line"><span class="comment">// func.bind(thisArg, arg1, arg2, ...);</span></span><br><span class="line"><span class="keyword">const</span> boundFunc = sayHello.<span class="title function_">bind</span>(person1, <span class="number">25</span>);</span><br><span class="line"><span class="title function_">boundFunc</span>(); <span class="comment">// Hello, my name is Alice and I am 25 years old.</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="浏览器-API"><a href="#浏览器-API" class="headerlink" title="浏览器 API"></a>浏览器 API</h3><h4 id="ajax-如何创建和使用"><a href="#ajax-如何创建和使用" class="headerlink" title="ajax 如何创建和使用"></a>ajax 如何创建和使用</h4><ol>
<li>实例化 XMLHttpRequest 对象:</li>
<li>open()准备发送求:</li>
<li>send()执行发送动作:</li>
<li>onreadystatechange 指定回调函数接收来自服务器端的请求,readyState 即为回调状态 responseText 返回内容</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> http = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">http.<span class="title function_">open</span>(post,<span class="string">&quot;https://www.baidu.com&quot;</span>,<span class="literal">false</span>)</span><br><span class="line"><span class="comment">//http.open(method,url,async);</span></span><br><span class="line">http.<span class="title function_">send</span>();</span><br><span class="line">http.<span class="property">onreadystatechange</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">if</span>(http.<span class="property">status</span> === <span class="number">200</span> &amp;&amp; http.<span class="property">readyState</span> === <span class="number">4</span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(http.<span class="property">responseText</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="本地存储与-Cookie-的区别"><a href="#本地存储与-Cookie-的区别" class="headerlink" title="本地存储与 Cookie 的区别"></a>本地存储与 Cookie 的区别</h4><ul>
<li>Cookie:它有 4kb 的大小限制,数据的生命周期比较灵活,不设置失效时间默认关闭浏览器后失效,原生 Cokkie 接口不好需要二次封装,可以通过它设置记住密码功能,存储的内容会保留在 HTTP 请求的 Header 中,并且会随每次请求发送到浏览器</li>
<li>本地储存:是 HTML5 新增技术,有 localStorage 和 sessionStorage 两种,他们可存储的大小为 5mb,localStorage 的生命周期是永久存储,sessionStorage 的生命周期是当页面关闭后销毁</li>
</ul>
<h4 id="Json-如何新增-删除键值对"><a href="#Json-如何新增-删除键值对" class="headerlink" title="Json 如何新增&#x2F;删除键值对"></a>Json 如何新增&#x2F;删除键值对</h4><ul>
<li>新增:<ul>
<li>使用数组下标形式添加 Object[“属性名”] &#x3D;’xxx’;</li>
<li>使用对象参数的形式添加 Object.属性名 &#x3D; ‘xxx’;</li>
</ul>
</li>
<li>删除:<ul>
<li>使用 delete 删除 delete Object.属性名</li>
</ul>
</li>
</ul>
<h4 id="ES6-新特性"><a href="#ES6-新特性" class="headerlink" title="ES6 新特性"></a>ES6 新特性</h4><ul>
<li>const 和 let<ul>
<li>Let 与 var 与 const 的区别<ul>
<li>var 声明的变量会挂载在 window 上,而 let 和 const 声明的变量不会</li>
<li>var 声明变量存在变量提升,let 和 const 不存在变量提升</li>
<li>let 和 const 声明形成块级作用域</li>
<li>同一作用域下 let 和 const 不能声明同名变量,而 var 可以</li>
<li>let 有暂存死区</li>
</ul>
</li>
</ul>
</li>
<li>模板字符串</li>
<li>箭头函数</li>
<li>函数的参数默认值</li>
<li>对象和数组解构</li>
<li>for…of 和 for…in</li>
<li>ES6 中的类</li>
<li>Promise 对象</li>
<li>async 函数</li>
</ul>
<h3 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h3><h4 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h4><ul>
<li>概念: 写一段自调用函数,函数体内声明变量后 return 出一个方法,在方法内引用数据并处理,之后随着函数的调用结束定义的数据不会被而释放,第一次调用后的值被保存了下来,所以形成了”闭包”.</li>
<li>原因：因为当声明一段函数时,它的作用域和变量就已经在内存中被声明了,因为 js 的垃圾处理机制是被引用的堆内存不会被释放.所以当变量被函数内部引用,函数执行完毕后作用域被销毁,但被引用的值不会被销毁,所以这些变量在闭包执行期间是永久性存在的</li>
<li>特性:<ol>
<li>函数内变量以私有成员的存在,避免了全局变量的污染</li>
<li>函数内部可以引用外部的参数和变量</li>
<li>这些变量的值始终保持在内存中,不会在外层函数调用后被自动清除</li>
<li>参数和变量不会被垃圾回收机制回收</li>
</ol>
</li>
<li>影响:<ul>
<li>常驻内存会增大内存的使用量,造成内存泄露</li>
</ul>
</li>
<li>用途:<ul>
<li>保存状态:<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这样并不会污染全局作用域,但是数据却可以拿到</span></span><br><span class="line"><span class="keyword">const</span> countNum = (<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    a += <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;)();</span><br><span class="line"><span class="title function_">countNum</span>(); <span class="comment">// 1</span></span><br><span class="line"><span class="title function_">countNum</span>(); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure></li>
<li>模块化:<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// moduleA.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> moduleA = (<span class="function">()=&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> data = <span class="string">&quot;this is my data&quot;</span>;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">getData</span>:<span class="function">()=&gt;</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> data</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)()</span><br><span class="line"><span class="comment">// moduleB.js</span></span><br><span class="line"><span class="keyword">import</span> moduleA <span class="keyword">from</span> moduleA.<span class="property">js</span></span><br><span class="line"><span class="keyword">const</span> data = moduleA.<span class="title function_">getData</span>() + <span class="string">&quot;deal&quot;</span>;</span><br><span class="line">...</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h4 id="什么是内存泄露"><a href="#什么是内存泄露" class="headerlink" title="什么是内存泄露?"></a>什么是内存泄露?</h4><ul>
<li>内存因为某些原因没有被垃圾回收装置回收成为常驻内存,造成系统内存的浪费,可能会导致程序运行速度减慢甚至崩溃</li>
</ul>
<h4 id="原型-原型链-继承"><a href="#原型-原型链-继承" class="headerlink" title="原型&#x2F;原型链&#x2F;继承"></a>原型&#x2F;原型链&#x2F;继承</h4><ul>
<li><p>概念:</p>
<ul>
<li>原型: 在 JS 中每个构造函数有一个原型对象,构造函数可以通过 prototype 去访问原型对象,而原型对象有一个 constructor 指回构造函数,构造函数可以生成一个实例,生成的实例有一个<strong>proto</strong>属性指向原型对象.</li>
<li>原型链:当访问 JS 中一个实例的方法和属性时,首先会查找自身；如果并未查找到,那么就会寻找实例的原型对象中是否存在,如果仍不存在,就会访问原型对象的原型对象.这个搜索链条就叫原型链<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">People</span>(<span class="params">name, sex</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">sex</span> = sex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">People</span>.<span class="property"><span class="keyword">prototype</span></span>; <span class="comment">// 原型对象</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>用途:</p>
<ul>
<li><p>用于继承</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Animal</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">step</span> = <span class="number">0</span>;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">category</span> = <span class="string">&quot;animal&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Animal</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">run</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">step</span> += <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Dog</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="title class_">Animal</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>); <span class="comment">// 实现Animal属性的继承</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使原型链继承</span></span><br><span class="line"><span class="title class_">Dog</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="title class_">Animal</span>.<span class="property"><span class="keyword">prototype</span></span>);</span><br><span class="line"><span class="title class_">Dog</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">construtor</span> = <span class="title class_">Dog</span>;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Dog</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">say</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;woof&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> xiaobai = <span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="string">&quot;xiaobai&quot;</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>继承:是面向对象编程中的一个重要概念,通过继承可以使子类的实例使用在父类中定义的属性和方法.[每当代码读取某个对象的某个属性时,都会执行一次搜索,目标是具有给定名字的属性.搜索首先从对象实例本身开始.如果在实例中找到了具有给定名字的属性,则返回该属性的值；如果没有找到,则继续搜索_proto_指针指向的原型对象,在原型对象中查找具有给定名字的属性.如果在原型对象中找到了这个属性,则返回该属性的值.]</p>
</li>
</ul>
<h4 id="同步与异步的区别-阻塞与非阻塞区别"><a href="#同步与异步的区别-阻塞与非阻塞区别" class="headerlink" title="同步与异步的区别&#x2F;阻塞与非阻塞区别"></a>同步与异步的区别&#x2F;阻塞与非阻塞区别</h4><blockquote>
<p>(<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_22855325/article/details/72958345">https://blog.csdn.net/qq_22855325/article/details/72958345</a>)</p>
</blockquote>
<ul>
<li>同步任务指的是,在主线程上排队执行的任务,只有前一个任务执行完毕,才能执行下一个任务；</li>
<li>异步任务指的是,不进入主线程、而进入”任务队列”,只有等主线程任务执行完毕,”任务队列”才开始通知主线程,请求执行任务,该任务才会进入主线程执行<br>[javascript 是单线程,所有任务需要排队,前一个任务结束,才会执行后一个任务]</li>
<li>阻塞:调用时,如果被调用者状态未就绪,会导致调用线程被挂起.</li>
<li>非阻塞:调用时,如果被调用者就绪则立即返回结果,如果未就绪也会返回一个错误值,告诉调用者当前的状态</li>
</ul>
<h4 id="请简述-async-的用法"><a href="#请简述-async-的用法" class="headerlink" title="请简述 async 的用法"></a>请简述 async 的用法</h4><blockquote>
<p>(<a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000007535316">https://segmentfault.com/a/1190000007535316</a>)</p>
</blockquote>
<ul>
<li>async 用于申明一个函数是异步的并且它会返回一个 Promise 对象,函数的返回值就是.then()里的数值<br>[await 只能出现在 async 函数中,await 在等待一个 async 函数完成,因为 async 函数返回一个 Promise 对象,所以 await 可以用于等待一个 async 函数的返回值——这也可以说是 await 在等 async 函数,但要清楚,它等的实际是一个返回值]</li>
</ul>
<h4 id="什么是-JSONP-工作原理是什么"><a href="#什么是-JSONP-工作原理是什么" class="headerlink" title="什么是 JSONP 工作原理是什么?"></a>什么是 JSONP 工作原理是什么?</h4><ul>
<li><p>工作原理: 通过 script 标签绕过同源策略 前端动态生成一个 script 标签向后端发送 get 请求,然后准备函数接收数据,并用 callback 为键将函数名发送给后端,后端接收函数名后将数据作为实参拼接一段执行调用函数的 js 代码返回给前端,前端接收到执行函数的代码后 script 标签 会自动调用声明的函数,函数的形参就是后端返回的数据.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 前端请求 &lt;script src=&quot;https://example.com/api?callback=dealData&quot;&gt;&lt;/script&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 服务器返回</span></span><br><span class="line"><span class="title function_">dealData</span>(&#123; <span class="attr">name</span>: <span class="string">&quot;Alice&quot;</span>, <span class="attr">age</span>: <span class="number">25</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 前端接收</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">dealData</span>(<span class="params">data</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="事件委托是什么-如何确定事件源"><a href="#事件委托是什么-如何确定事件源" class="headerlink" title="事件委托是什么?如何确定事件源"></a>事件委托是什么?如何确定事件源</h4><ul>
<li>事件委托就是利用事件冒泡机制,只给一个元素绑定事件,就可以代理管理某一类型的所有事件.这样可以避免绑定一大堆事件,优化性能</li>
<li>事件源通过事件对象的 target 属性来确定</li>
</ul>
<h4 id="This-指向"><a href="#This-指向" class="headerlink" title="This 指向"></a>This 指向</h4><ol>
<li>在一般函数内或全局作用域下,指向的 window 对象</li>
<li>在对象的方法中,指向的该对象</li>
<li>在事件处理函数中,指向触发事件的元素(Node 节点)</li>
<li>在箭头函数中: 继承上一级的指向位置(无视当前函数)</li>
<li>在构造函数中,指向的是实例化对象.(需要 new 的对象)</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">People</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">sayMyName</span> = <span class="title function_">alert</span>(name);</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> student = <span class="keyword">new</span> <span class="title class_">People</span>(<span class="string">&quot;二狗&quot;</span>, <span class="number">18</span>);</span><br><span class="line">student.<span class="property">sayMyName</span>;</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>在新增原型对象属性中,this 指的就是这个原型的主人(实例化的对象)</li>
</ol>
<h4 id="箭头函数与普通函数的区别"><a href="#箭头函数与普通函数的区别" class="headerlink" title="箭头函数与普通函数的区别"></a>箭头函数与普通函数的区别</h4><ul>
<li>箭头函数都是匿名函数,没有自己 this,arguments,原型对象</li>
</ul>
<h4 id="普通函数和构造函数的区别"><a href="#普通函数和构造函数的区别" class="headerlink" title="普通函数和构造函数的区别"></a>普通函数和构造函数的区别</h4><ol>
<li>写法不同构造函数习惯上首字母大写</li>
<li>调用方式不一样,普通函数可以用 函数名() 的形式直接调用,构造函数需要用 new 关键字来调用创建实例对象</li>
<li>返回值不一样,普通函数返回值由 return 决定,构造函数返回值是实例化的对象</li>
</ol>
<h4 id="什么是面向对象请简述"><a href="#什么是面向对象请简述" class="headerlink" title="什么是面向对象请简述"></a>什么是面向对象请简述</h4><ul>
<li>面向对象的三大特征 继承、封装、多态<ul>
<li>继承:通过继承使子类可以使用在父类中定义的属性和方法</li>
<li>封装:就是指把内部的实现封装起来,然后暴露必要的方法让外部调用.</li>
<li>多态:多态指的是同一类事物有多种形态,如文件有:文本文件,可执行文件,视频文件等…</li>
</ul>
</li>
</ul>
<h4 id="重绘以及回流是什么"><a href="#重绘以及回流是什么" class="headerlink" title="重绘以及回流是什么"></a>重绘以及回流是什么</h4><ul>
<li>重绘(repaint):当元素样式的改变不影响布局时,浏览器将使用重绘对元素进行更新,此时由于只需要 UI 层面的重新像素绘制,因此损耗较少,常见的重绘操作有:改变元素颜色</li>
<li>回流(reflow):当元素的尺寸、结构或者触发某些属性时,浏览器会重新渲染页面,称为回流.此时,浏览器需要重新经过计算,计算后还需要重新页面布局,因此是较重的操作.常见的回流操作有:浏览器窗口大小改变,添加或者删除可见的 DOM 元素</li>
<li>回流必定会触发重绘,重绘不一定会触发回流.重绘的开销较小,回流的代价较高.</li>
</ul>
<h4 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h4><ul>
<li>解释: JS 是单线程的语言,为了避免阻塞主线,它引入了事件循环机制来处理异步任务,JS 会先执行同步任务,遇到异步任务的时候会交给 Web API,当异步任务执行完成的时候,会将回调函数放入 任务队列 Task Queue &#x2F; Callback Queue 然后 Event Loop 事件循环 负责一直监听任务队列 执行队列中的任务</li>
<li>宏任务微任务:遇到同步任务直接执行,遇到异步任务分类为宏任务(macro-task)和微任务(micro-task).有微则微,无微则宏:<ul>
<li>宏任务: 整体代码 定时器 ajax DOM 事件</li>
<li>微任务: promise async&#x2F;await</li>
</ul>
</li>
<li>微任务 &gt; DOM 渲染 &gt; 宏任务</li>
</ul>
<h4 id="深浅拷贝"><a href="#深浅拷贝" class="headerlink" title="深浅拷贝"></a>深浅拷贝</h4><ul>
<li>是什么如何实现?<ul>
<li>js 有两种类型基本类型和引用类型,基本类型它的名和值会储存在栈内存中,当我们复制它时会开一条新内存再创建一个同样的值,但是引用类型在我们新建的时候它会在栈内存中储存它的名和一个指向它堆内存的地址,当我们复制的时候其实只是复制了它的引用地址并非堆里面的值,如果要深拷贝我们就需要新建一个和它一样的堆内存的值</li>
</ul>
</li>
<li>什么时候用深拷贝&#x2F;浅拷贝<ul>
<li>当我们创建了一个对象并复制,如果我们想修改复制的对象,但却不想让原对象也随之改变的时候使用深拷贝,但是如果我们只是想复制它的基本类型的数据或者指向它的堆内存的指针的时候使用浅拷贝</li>
</ul>
</li>
<li>深拷贝的代码实现<ul>
<li>简单深拷贝(一层拷贝)<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">deepCopy</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> copyObj = <span class="title class_">Array</span>.<span class="title function_">isArray</span>(obj) ? [] : &#123;&#125;;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">    copyObj[key] = obj[key];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> copyObj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>复杂深拷贝(递归实现多层拷贝)<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">deepCopy</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> copyObj = <span class="title class_">Array</span>.<span class="title function_">isArray</span>(obj) ? [] : &#123;&#125;;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">    <span class="keyword">if</span> (obj.<span class="title function_">hasOwnProperty</span>(key)) &#123;</span><br><span class="line">      copyObj[key] =</span><br><span class="line">        <span class="keyword">typeof</span> obj[key] === <span class="string">&quot;object&quot;</span> ? <span class="title function_">deepCopy</span>(obj[key]) : obj[key];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> copyObj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h4 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h4><ul>
<li>理解: promise 是为解决异步处理回调地狱问题而产生的;它是一个构造函数,可以通过 new 得到一个 Promise 的实例对象,Promise 里有两个函数分别叫做 resolve(成功之后的回调函数)和 reject(失败之后的回调函数)在 Promise 构造函数的 Prototype 属性上,有一个.then()和.catch()方法,只要是 Promise 的实例化对象都可以使用</li>
<li>Promise 在哪里使用过<ul>
<li>在使用 ajax,axios 等一类的数据请求的时候用过,只要是一些需要解决回调函数问题的都可以用(在函数中 return 一个 promise 实例,成功后干嘛失败后干嘛,则该函数就可以使用.then 和 catch 方法)</li>
</ul>
</li>
</ul>
<h4 id="函数节流和防抖"><a href="#函数节流和防抖" class="headerlink" title="函数节流和防抖"></a>函数节流和防抖</h4><ul>
<li>函数节流:<blockquote>
<p>(<a target="_blank" rel="noopener" href="https://www.cnblogs.com/fightjianxian/p/12077570.html">https://www.cnblogs.com/fightjianxian/p/12077570.html</a>)</p>
</blockquote>
<ul>
<li>作用: 在 n 秒中只执行一次函数(指定时间间隔内只会执行一次任务)</li>
<li>实现:<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数节流</span></span><br><span class="line"><span class="keyword">var</span> pass = <span class="literal">true</span>;</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;throttle&quot;</span>).<span class="property">onscroll</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!pass) &#123;</span><br><span class="line">    <span class="comment">// 判断是否已空闲,如果在执行中,则直接return</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  pass = <span class="literal">false</span>;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;函数节流&quot;</span>);</span><br><span class="line">    pass = <span class="literal">true</span>;</span><br><span class="line">  &#125;, <span class="number">300</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li>应用场景: 高频触发的事件,多数在监听页面元素滚动事件</li>
</ul>
</li>
<li>函数防抖:<blockquote>
<p>(<a target="_blank" rel="noopener" href="https://www.cnblogs.com/fightjianxian/p/12077451.html">https://www.cnblogs.com/fightjianxian/p/12077451.html</a>)</p>
</blockquote>
<ul>
<li>作用: 在 n 秒内函数只能执行一次,如果在 n 秒内又触发了事件,则会重新计算函数执行时间(任务频繁触发的情况下,只有任务触发的间隔超过指定间隔,任务才会执行)</li>
<li>实现:<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> timer = <span class="literal">false</span>;</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;debounce&quot;</span>).<span class="property">onscroll</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="built_in">clearTimeout</span>(timer); <span class="comment">// 清除未执行的代码,重置回初始化状态</span></span><br><span class="line">  timer = <span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;函数防抖&quot;</span>);</span><br><span class="line">  &#125;, <span class="number">300</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li>应用场景:如邮箱验证和手机号验证.只有等用户输入完毕后,前端才需要检查格式是否正确,如果不正确,再弹出提示语</li>
</ul>
</li>
</ul>
<h3 id="VUE"><a href="#VUE" class="headerlink" title="VUE"></a>VUE</h3><h4 id="VUE2"><a href="#VUE2" class="headerlink" title="VUE2"></a>VUE2</h4><ul>
<li><p>Vue 的核心是什么</p>
<ul>
<li>数据驱动和组件化</li>
<li>数据驱动:视图的内容随着数据的改变而改变</li>
<li>组件化:把页面封装成为若干个组件进行拼装,让页面的复用性达到最高</li>
</ul>
</li>
<li><p>请简述你对 vue 的理解</p>
<ul>
<li>一套渐进式的自底向上增量开发的前端 MVVM 框架<ul>
<li>渐进式:可以只使用部分功能,也可以整个用 vue 开发,不做职责之外的事</li>
<li>自底向上增量开发:先编写出基础页面,再逐步扩大规模,补充和升级某些功能和效果</li>
<li>M 代表模型层也是数据层 V 代表视图层,VM 是用来沟通的桥梁,负责监听模型层或者视图层的修改</li>
</ul>
</li>
</ul>
</li>
<li><p>mvvm 框架是什么?</p>
<ul>
<li>M 代表数据层 V 代表视图层,VM 是用来沟通的桥梁,负责监听模型层或者视图层的修改</li>
<li>区别:vue 数据驱动,通过数据来显示视图层而不是节点操作.</li>
<li>场景:数据操作比较多的场景,更加便捷.</li>
</ul>
</li>
<li><p>MVVM 与 MVC 的区别</p>
<ul>
<li>MVC 中 Model 和 View 还有 Controller 是完全独立的,由 Controller 作为中间人来负责二者的交互</li>
<li>MVVM 中 VM 是 V 与 M 沟通的桥梁,开发者只需关注业务逻辑,不需要手动操作 DOM,不需要关注数据状态的同步问题,复杂的数据状态维护完全由 MVVM 来管理</li>
</ul>
</li>
<li><p>请简述 vue 的单向数据流</p>
<ul>
<li>组件之间一旦传值完毕,接收数据的这个组件无论怎么修改,传递数据的那个组件的数据都不会改变;我们经常会采用父子组件通过正向&#x2F;逆向传值来对数据进行传递.以上的这些模式非常脆弱,通常会导致无法维护的代码.</li>
</ul>
</li>
<li><p>Vue 常用的修饰符有哪些</p>
<ul>
<li>事件修饰符:<ul>
<li>prevent(阻止事件的默认行为)</li>
<li>stop(阻止事件冒泡)</li>
<li>capture(让事件传递成为捕获)</li>
<li>self(只会触发自己范围内的事件,不包含子元素)</li>
<li>once(只会触发一次)</li>
</ul>
</li>
<li>按键修饰符(按下某个键):up down ctrl enter space</li>
</ul>
</li>
<li><p>什么是计算属性</p>
<ul>
<li>它是一种属性,有“计算”这个特殊性质.每次取得它的值得时候,它并不像普通属性那样直接返回结果,而是经过一系列的计算之后再返回结果.</li>
</ul>
</li>
<li><p>计算属性与 watch 区别</p>
<ul>
<li>计算属性是依赖于缓存的,当依赖的值发生改变才会触发.而 watch 是当 watch 监听的值发生改变就会被调用相应方法</li>
<li>计算属性适合在数据展示时做一些处理</li>
</ul>
</li>
<li><p>Vue 如何定义一个过滤器</p>
<ul>
<li>&#96;全局过滤器使用 Vue.filter(‘过滤器名字’,function(val){return 返回的内容})在 app.vue 中</li>
<li>局部过滤器使用 filters(‘’,function(val){})在 data 同级</li>
<li>通过 { { 要过滤的数据|过滤器名 } }来调用</li>
</ul>
</li>
<li><p>Vue 循环的 key 作用</p>
<ul>
<li>key 的作用主要是为了高效的更新虚拟 DOM,是遍历数组或元素中的唯一标识,增加或删减元素时,通过 key 判断是否是之前的元素,如果是则直接会复用该标签,不会将所有标签重新删除和创建,只会重新渲染数据,然后再创建新的元素直到数据渲染完为止</li>
</ul>
</li>
<li><p>v-for 与 v-if 优先级</p>
<ul>
<li>v-for 比 v-if 具有更高的优先级,但是不能把 v-if 与 v-for 用在同一个元素上,因为如果两者同时出现的话,那每次循环都会执行 v-if,会很浪费性能</li>
</ul>
</li>
<li><p>Vue 单页面的优缺点</p>
<ul>
<li>优点:用户体验好,速度快,内容的改变不需要再加载整个页面,前后端分离,组件化便于修改和调整</li>
<li>缺点:初次加载耗时高,页面复杂度提高,导航需要自行实现前进后退,不利于 seo 搜索引擎优化</li>
</ul>
</li>
<li><p>Vue 的生命周期请简述</p>
<ul>
<li>beforeCreate:创建 vue 实例前</li>
<li>created:创建实例完成后,开始监听 data 对象数据变化情况,初始化 VUE 内部事件</li>
<li>beforeMount:编译模板,把 data 里面的数据和模板生成 html</li>
<li>mounted:用编译好的 html 替换掉 el 属性所指向的 DOM 对象</li>
<li>beforeUpate:数据更新前</li>
<li>updated:数据更新后</li>
<li>beforedestroy:销毁实例前</li>
<li>destroyed:销毁所有事件监听器和子实例,完成销毁 vue 实例</li>
</ul>
</li>
<li><p>Vue 生命周期的作用:</p>
<ul>
<li>给使用者在不同阶段添加自己的代码的机会</li>
</ul>
</li>
<li><p>DOM 渲染在那个生命周期阶段内完成</p>
<ul>
<li>mounted</li>
</ul>
</li>
<li><p>Vue 中路由跳转方式(声明式&#x2F;编程式)</p>
<ul>
<li>声明式: <router-link></li>
<li>编程式: this.$router.push(“&#x2F;路由名”)</li>
</ul>
</li>
<li><p>跨域的解决方式</p>
<ol>
<li>在 vue.config.js 中进行 proxy 配置</li>
<li>在后台用 cors 跨域</li>
</ol>
</li>
<li><p>Vue 路由的实现</p>
<ul>
<li>通过 hash 和 history 两种模式来实现,它们分别基于 location 和 history 对象</li>
</ul>
</li>
<li><p>Vue 路由模式 hash 和 history,简单讲一下</p>
<ul>
<li>hash 模式:基于 location 对象,地址栏会出现#(hash)符,只有#前的内容会被包含在请求中,前端路由修改的是#后的信息,所以刷新是不会向服务端请求添加#后面的参数,所以刷新不会出问题</li>
<li>history 模式:基于 History 对象,前端的 URL 必须和实际向后端发起请求的 URL 一致,不然会出现 404 错误(比如刷新的时候),需要后端配置一下 apache 或是 nginx 的 url 重定向,重定向到我的首页路由上.</li>
</ul>
</li>
<li><p>Vue 路由懒加载(按需加载路由)</p>
<ul>
<li>因为 vue 的路由技术是为了完成单页面应用的,在第一次页面初始化的时候路由会把所有的路由页面都渲染好可能会造成用户的页面白屏相应慢: component:()&#x3D;&gt;import(‘路由组件路径’)</li>
</ul>
</li>
<li><p>Route 与 router 区别</p>
<ul>
<li>route 对象表示当前的路由信息,是一个局部对象,包含了当前 URL 解析得到的信息.包含当前的路径,参数,query 对象等.</li>
<li>router 对象是全局路由的实例,他包含所有的路由拥有的对应的对象,属性和方法.比如 history 对象</li>
</ul>
</li>
<li><p>Vue 路由传参的两种方式,prams 和 query 方式与区别</p>
<ul>
<li>params:需要在路由规则中绑定接收的参数名,通过路由规则的 name 值来绑定发送的参数,传递的参数不会暴露在地址栏相对安全</li>
<li>query:不需要在路由规则中绑定参数名,通过路由规则的 path 路径来绑定发送的参数,传递的参数会暴露在地址栏不安全</li>
</ul>
</li>
<li><p>Vue 数据绑定的几种方式</p>
<ul>
<li>普通文本绑定 v-text</li>
<li>解释 HTML 标签的绑定 v-html</li>
<li>数据特殊属性 v-bind</li>
<li>双向绑定 v-model</li>
</ul>
</li>
<li><p>Vue 注册一个全局组件</p>
<ol>
<li>在 main.js 通过 import 引入封装的组件</li>
<li>使用 vue.component(“设置使用时的组件名”,引入的组件)</li>
</ol>
</li>
<li><p>Vue 的路由钩子函数&#x2F;路由守卫有哪些</p>
<ul>
<li>全局钩子:<ul>
<li>路由前置:router.beforeEach((to,from,next)&#x3D;&gt;{})</li>
<li>路由后置:router.afterEach((to,from,next)&#x3D;&gt;{})</li>
</ul>
</li>
<li>路由独享钩子:在路由规则中写入 只有前置 beforeEnter:(to,from,next)&#x3D;&gt;{}</li>
<li>组件内钩子:beforeRouteEnter(to,from,next){} beforeRouteLeave(to,from,next){}</li>
</ul>
</li>
<li><p>Vue 中如何进行动态路由设置?有哪些方式?怎么获取传递过来的数据?</p>
<ul>
<li>前端列表页点击之后通过 params 或 query 的声明式(<router-link to=""></router-link>)或编程式发送参数(this.$router.push(name&#x2F;路径,params&#x2F;query:{}))如果使用 params 传参需要在路由规则中配置接收参数的参数名</li>
<li>最后详情页再通过 this.$route.params&#x2F;query.接收的参数名后 发送不同参数的请求接收不同的数据渲染页面</li>
</ul>
</li>
<li><p>Vue 中指令有哪些</p>
<ul>
<li>v-text 将普通数据显示在页面上</li>
<li>v-html 输出 html 内容</li>
<li>v-show 控制元素的显示和隐藏</li>
<li>v-if 判断是否加载内容 v-else-if:满足一项先执行它 v-else:不然就执行它</li>
<li>v-model 用于表单的双向绑定</li>
<li>v-for 遍历数据</li>
<li>v-bind 绑定特殊属性</li>
<li>v-once 只渲染一次 数据改变不会影响该值的变化</li>
<li>v-on 绑定事件</li>
</ul>
</li>
<li><p>v-on 可以绑定多个方法吗</p>
<ul>
<li>可以 使用 v-on”{ click:dbclick,mouseomve:mouseclick }”</li>
</ul>
</li>
<li><p>Vue-cli 中如何自定义指令</p>
<ul>
<li>自定义指令有 5 个钩子;<ul>
<li>bind 代表绑定指令到元素上,只执行一次</li>
<li>inserted 代表绑定指令的元素插入到页面时就调用(常用)</li>
<li>componentUpdated:指令所在组件的节点及其子节点全部更新完成后调用</li>
<li>update:所有组件节点更新时调用</li>
<li>unbind:解除指令和元素的绑定,只执行一次</li>
</ul>
</li>
<li>如果时局部指令使用 directives:{ 自定义指令的名字:{ 钩子函数(el){ 操作逻辑 } } }写在 data 同级</li>
<li>如果时全局使用 Vue.directive(‘自定义的名字’,{钩子函数(el){ 操作逻辑 } })</li>
</ul>
</li>
<li><p>Watch 请简述</p>
<ul>
<li>监听 data 模型数据 当模型数据改变的时候就会触发;watch 初始化的时候不会运行,只有数据被改变之后才会运行</li>
</ul>
</li>
<li><p>v-text 与区别{ { } }</p>
<ul>
<li>{ { } }是模板插值,v-text 是指令,模板插值 { { } } 如果数据过多可能会把大括号显示出来(屏幕闪动)需要使用 v-cloak 指令</li>
</ul>
</li>
<li><p>对 vue 中 keep-alive 的理解</p>
<ul>
<li>切换过程中将状态保留在内存中,防止重复渲染 DOM,减少加载时间及性能消耗,提高用户体验性</li>
<li>用<keep-alive>元素将其路由出口包裹起来;它有两个钩子函数 activated(激活后)和 deactivated(停用后)</li>
</ul>
</li>
<li><p>如何让组件中的 css 在当前组件生效</p>
<ul>
<li>在组件中的 style 前面加上 scoped</li>
</ul>
</li>
<li><p>Vue 组件中的 data 为什么是函数</p>
<ul>
<li>data 数据会以函数返回值形式定义,这样每复用一次组件,就会返回一份新的 data,相当于给每个组件实例创建一个私有的数据空间,让各个组件实例维护各自的数据.如果是对象形式,就使得所有组件实例共用了一份 data,就会造成数据的公用的结果.</li>
</ul>
</li>
<li><p>Vue 双数据绑定过程中,这边儿数据改变了怎么通知另一边改变</p>
<ul>
<li>当我们读取或者设置对象属性的时候,都会触发 Object.defineProperty()函数的 get 和 set 方法,在这两个方法中添加操作从而劫持数据,当属性发生变化的时候,会执行一系列的渲染视图操作</li>
</ul>
</li>
<li><p>Vue 双向绑定的原理</p>
<ul>
<li>数据劫持:当我们读取或者设置对象属性的时候,都会触发 Object.defineProperty()函数的 get 和 set 方法,在这两个方法中添加操作从而劫持数据,当属性发生变化的时候,会执行一系列的渲染视图操作</li>
<li>发布者订阅模式:对象间一种一对多的依赖关系,当一个对象的状态发生改变时,所有依赖于它的对象都将得到通知.</li>
</ul>
</li>
<li><p>Vue 中组件怎么传值</p>
<ul>
<li>正向传值:<ol>
<li>在子组件用 props 新建一个数据名并使用,来接收父组件传过来的值</li>
<li>在父组件中使用子组件,并以特殊属性的方式,把需要传递的数据通过 props 数据名传递给子组件</li>
</ol>
</li>
<li>逆向传值:可以使用自定义事件传值 或者 ref 获取节点传值或 vuex 传值<ol>
<li>需通过事件函数来触发一个自定义事件: this.$emit(“自定义事件名”,传递的数据)</li>
<li>在使用子组件的父组件中,使用事件绑定指令绑定抛出的自定义事件名并让其等于一个函数,函数的形参就是传递的数据</li>
</ol>
</li>
</ul>
</li>
<li><p>Vue 兄弟组件传值</p>
<ul>
<li>可以使用传统的子传父 父再传子的办法或 vuex 或者 eventBus<ol>
<li>在父组件中使用两个子组件让其成为兄弟</li>
<li>在兄弟 a 引入事件总线,并通过事件函数来触发一个自定义事件 eventBus.$emit(“自定义事件名”,”要传递的数据”)</li>
<li>在兄弟 b 引入事件总线,在钩子函数中使用 eventBus.$on(“自定义事件名”,(val)&#x3D;&gt;{})接收传递的数据,回调函数中的形参就是传递的数据</li>
</ol>
</li>
</ul>
</li>
<li><p>请简述插槽</p>
<ul>
<li>父组件中子组件中数量不同内容也不相同的时候使用的技术;<br>子组件中插入<slot></slot> 则可在父组件的子组件开标签内部写入标签和内容</li>
</ul>
</li>
<li><p>Vue 首屏加载慢的原因,怎么解决的,白屏时间怎么检测,怎么解决白屏问题</p>
<ul>
<li>使用路由懒加载(还有如将第三方依赖打包进入 CDN 服务器,按需引入 ui,压缩代码,精灵图等等)</li>
</ul>
</li>
<li><p>Vuex 是什么?怎么使用?在那种场景下使用?</p>
<ul>
<li>状态(数据)管理工具,就是一个数据的仓库,将数据全部存入仓库,组件就可以自由使用数据</li>
<li>将数据保存在 state 中,通过(this.$store.state.数据名)来调用数据,修改数据在Mutations中,在Actions调用mutations中的方法异步操作数据,在需要使用的组件通过this.$store.dispatch()来调用和传递实参</li>
<li>用于开发中大型 web 单页应用中对应用的状态进行管理或解决组件间数据通信麻烦的问题</li>
</ul>
</li>
<li><p>vuex 的优势</p>
<ol>
<li>能够集中管理和共享数据,易于开发和维护</li>
<li>能够高效地实现组件之间的数据传递,提高开发效率</li>
<li>数据都是响应式的,能够实时保持数据与页面的同步</li>
</ol>
</li>
<li><p>Vuex 怎么请求异步数据</p>
<ul>
<li>在 action 使用封装的 axios 发送请求,接收到数据后使用 commit 调用 mutation 给 state 数据赋值</li>
</ul>
</li>
<li><p>Vuex 中 action 如何提交给 mutation 的</p>
<ul>
<li>在组件内通过 this.$store.dispatch()调用 action 的方法并传递实参,在 action 中使用 commit 调用 mutation 方法,通过 mutation 修改 state 中的数据</li>
</ul>
</li>
<li><p>vuex 有哪几种状态和属性</p>
<ul>
<li>数据保存的地方:State</li>
<li>对数据过滤的:Getter</li>
<li>修改数据的:Mutation</li>
<li>处理异步操作的:Action</li>
<li>让数据模块化的:Module</li>
</ul>
</li>
<li><p>vuex 的 State 特性是?</p>
<ul>
<li>state 就是存放数据的仓库,特性就是若 store 中的 state 数据发生改变,依赖这个数据的组件也会相应更新(当 mutation 修改了 state 的数据的时候,他会动态的去修改所有的调用这个变量的组件里的值)</li>
</ul>
</li>
<li><p>vuex 的 Getter 特性是?</p>
<ul>
<li>getter 用来获取数据,类似于计算属性</li>
</ul>
</li>
<li><p>vuex 的 Mutation 特性是?</p>
<ul>
<li>同步执行,修改 state 数据的唯一途径,直接变更 state 数据.</li>
</ul>
</li>
<li><p>vuex 的 actions 特性是?</p>
<ul>
<li>用于异步请求数据,不能直接操作 state,需要通过提交给 mutation 来修改 state 数据</li>
</ul>
</li>
<li><p>$set:解决 data 数据改变和视图不改变(vue3.0 以上已解决,面试常问)</p>
</li>
<li><p>vue 中的拖拽+js 原生拖拽说思路？</p>
<ol>
<li>需要三个事件 鼠标 按下\移动\抬起</li>
<li>当按下时获取鼠标点击元素的内部鼠标的位置<br>移动时获取鼠标在页面的位置并减去元素内部鼠标的位置,同时判断边界条件,当减去的位置的 x 轴小于零代表出屏幕的左边,当减去的位置的 y 轴小于零代表出屏幕的右边,当大于时则需要算出页面的宽度高度(window.innnerXXX)减去元素的宽高度,当大于这个值就等于这个值,<br>当抬起时把移动的事件归位为 null</li>
</ol>
</li>
<li><p>vue 中 assets 和 public 里的静态区别?</p>
<ul>
<li>public 放不会变动的文件(相当于 vue-cli2.x 中的 static)public&#x2F; 目录下的文件并不会被 Webpack 处理:它们会直接被复制到最终的打包目录(默认是 dist&#x2F;static)下.必须使用绝对路径引用这些文件,这个取决于你 vue.config.js 中 publicPath 的配置,默认的是&#x2F;.</li>
<li>assets 放可能会变动的文件 assets 目录中的文件会被 webpack 处理解析为模块依赖,只支持相对路径形式.简单来说就是就是 public 放别人家 js 文件(也就是不会变动),assets 放自己写的 js 文件(需要改动的文件)</li>
</ul>
</li>
<li><p>怎么提升页面性能?性能优化有哪些?</p>
<ul>
<li>不用将所有的数据都在 data 中注册,不需要响应式的数据可以定义在实例上</li>
<li>v-for 循环生产的代码,要操作 dom 可以用事件委托</li>
<li>使用 keep-alive 缓存组件,防止切换路由时来回创建组件浪费性能</li>
<li>如果没有安全性考虑使用 v-show 代替 v-if 指令</li>
<li>使用路由懒加载</li>
</ul>
</li>
</ul>
<h4 id="VUE3"><a href="#VUE3" class="headerlink" title="VUE3"></a>VUE3</h4><ul>
<li><p>VUE3 的数据劫持原理</p>
<ul>
<li>VUE3 采用 ES6 的 Proxy 来监听数据的变化,它可以监听整个数据,而不是像 Object.defineProperty 只能监听单个属性。 它解决了 VUE2 中使用 Object.defineProperty 但不能监听数组和对象的增删的问题,Vue2 处理数组和对象时,会修改数组的原型的方法,对象的话会通过 Vue.set 和 Vue.delete 去手动更新视图。而 VUE3 中 Proxy 直接就可以监听对象和数组,不用再这样曲线操作</li>
</ul>
</li>
<li><p>Vue3 和 vue2 的区别</p>
<ul>
<li>源码组织方式变化：使用 TS 重写</li>
<li>支持 Composition API：基于函数的 API，更加灵活组织组件逻辑（vue2 用的是 options api）</li>
<li>响应式系统提升：Vue3 中响应式数据原理改成 proxy，可监听动态新增删除属性，以及数组变化</li>
<li>编译优化：vue2 通过标记静态根节点优化 diff，Vue3 标记和提升所有静态根节点，diff 的时候只需要对比动态节点内容</li>
<li>打包体积优化：移除了一些不常用的 api（inline-template、filter）</li>
<li>生命周期的变化：使用 setup 代替了之前的 beforeCreate 和 created</li>
<li>Vue3 的 template 模板支持多个根标签</li>
<li>Vuex 状态管理：创建实例的方式改变,Vue2 为 new Store , Vue3 为 createStore</li>
<li>Route 获取页面实例与路由信息：vue2 通过 this 获取 router 实例，vue3 通过使用 getCurrentInstance&#x2F; userRoute 和 userRouter 方法获取当前组件实例</li>
<li>Props 的使用变化：vue2 通过 this 获取 props 里面的内容，vue3 直接通过 props</li>
<li>父子组件传值：vue3 在向父组件传回数据时，如使用的自定义名称，如 backData，则需要在 emits 中定义一下</li>
</ul>
</li>
<li><p>Vue3 组件间如何传值？有哪些方式？</p>
<ul>
<li><p>props 传值（父 → 子）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 父组件</span><br><span class="line">&lt;Child :msg=&quot;message&quot; /&gt;</span><br><span class="line">// 子组件</span><br><span class="line">&lt;script setup&gt;</span><br><span class="line">defineProps(&#123;</span><br><span class="line">  msg: String,</span><br><span class="line">&#125;);</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;p&gt;接收到的消息：&#123;&#123; msg &#125;&#125;&lt;/p&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>emit 事件传值（子 → 父）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 子组件</span><br><span class="line">&lt;script setup&gt;</span><br><span class="line">const emit = defineEmits([&quot;sendData&quot;]);</span><br><span class="line">function sendMsg() &#123;</span><br><span class="line">  emit(&quot;sendData&quot;, &quot;Hello Parent!&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;button @click=&quot;sendMsg&quot;&gt;发送消息&lt;/button&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">// 父组件</span><br><span class="line">&lt;Child @sendData=&quot;handleData&quot; /&gt;</span><br><span class="line">&lt;script setup&gt;</span><br><span class="line">function handleData(data) &#123;</span><br><span class="line">  console.log(&quot;收到子组件的数据：&quot;, data);</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>v-model 进行双向绑定（Vue3 支持多个 v-model，可用于复杂组件。）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// 父组件</span><br><span class="line">&lt;Child v-model=&quot;text&quot; /&gt;</span><br><span class="line">&lt;script setup&gt;</span><br><span class="line">import &#123; ref &#125; from &quot;vue&quot;;</span><br><span class="line">const text = ref(&quot;Hello&quot;);</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">// 子组件</span><br><span class="line">&lt;script setup&gt;</span><br><span class="line">defineProps([&quot;modelValue&quot;]);</span><br><span class="line">const emit = defineEmits([&quot;update:modelValue&quot;]);</span><br><span class="line">function updateValue() &#123;</span><br><span class="line">  emit(&quot;update:modelValue&quot;, &quot;新的值&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;p&gt;当前值：&#123;&#123; modelValue &#125;&#125;&lt;/p&gt;</span><br><span class="line">  &lt;button @click=&quot;updateValue&quot;&gt;修改值&lt;/button&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// 父组件</span><br><span class="line">&lt;Child v-model:title=&quot;title&quot; v-model:desc=&quot;desc&quot; /&gt;</span><br><span class="line">&lt;script setup&gt;</span><br><span class="line">import &#123; ref &#125; from &quot;vue&quot;;</span><br><span class="line">const title = ref(&quot;Vue3&quot;);</span><br><span class="line">const desc = ref(&quot;双向绑定多个值&quot;);</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">// 子组件</span><br><span class="line">&lt;script setup&gt;</span><br><span class="line">defineProps([&quot;title&quot;, &quot;desc&quot;]);</span><br><span class="line">const emit = defineEmits([&quot;update:title&quot;, &quot;update:desc&quot;]);</span><br><span class="line"></span><br><span class="line">function updateValues() &#123;</span><br><span class="line">  emit(&quot;update:title&quot;, &quot;新标题&quot;);</span><br><span class="line">  emit(&quot;update:desc&quot;, &quot;新描述&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;button @click=&quot;updateValues&quot;&gt;修改值&lt;/button&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>provide&#x2F;inject 跨组件传值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 父组件</span><br><span class="line">&lt;script setup&gt;</span><br><span class="line">import &#123; provide, ref &#125; from &quot;vue&quot;;</span><br><span class="line">const theme = ref(&quot;dark&quot;);</span><br><span class="line">provide(&quot;theme&quot;, theme);</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;Child /&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">// 子组件</span><br><span class="line">&lt;script setup&gt;</span><br><span class="line">import &#123; inject &#125; from &quot;vue&quot;;</span><br><span class="line">const theme = inject(&quot;theme&quot;);</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;p&gt;当前主题：&#123;&#123; theme &#125;&#125;&lt;/p&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>ref 共享数据</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// store.js import &#123; reactive &#125; from &quot;vue&quot;; export const globalState =</span><br><span class="line">reactive(&#123; count: 0 &#125;); // 组件 A</span><br><span class="line">&lt;script setup&gt;</span><br><span class="line">import &#123; globalState &#125; from &quot;@/store.js&quot;;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;button @click=&quot;globalState.count++&quot;&gt;增加&lt;/button&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">// 组件 B</span><br><span class="line">&lt;script setup&gt;</span><br><span class="line">import &#123; globalState &#125; from &quot;@/store.js&quot;;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;p&gt;当前值：&#123;&#123; globalState.count &#125;&#125;&lt;/p&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>defineExpose 父组件访问子组件方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">// 子组件</span><br><span class="line">&lt;script setup&gt;</span><br><span class="line">import &#123; ref &#125; from &quot;vue&quot;;</span><br><span class="line">const count = ref(0);</span><br><span class="line"></span><br><span class="line">function increment() &#123;</span><br><span class="line">  count.value++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 暴露 `increment` 方法</span><br><span class="line">defineExpose(&#123; increment &#125;);</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">// 父组件</span><br><span class="line">&lt;script setup&gt;</span><br><span class="line">import &#123; ref &#125; from &quot;vue&quot;;</span><br><span class="line">import Child from &quot;./Child.vue&quot;;</span><br><span class="line"></span><br><span class="line">const childRef = ref(null);</span><br><span class="line"></span><br><span class="line">function callChildMethod() &#123;</span><br><span class="line">  childRef.value.increment();</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;Child ref=&quot;childRef&quot; /&gt;</span><br><span class="line">  &lt;button @click=&quot;callChildMethod&quot;&gt;调用子组件方法&lt;/button&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>mitt 事件总线（兄弟组件传值）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// eventBus.js import mitt from &quot;mitt&quot;; export const eventBus = mitt(); //</span><br><span class="line">组件 A（发送数据）</span><br><span class="line">&lt;script setup&gt;</span><br><span class="line">import &#123; eventBus &#125; from &quot;@/eventBus.js&quot;;</span><br><span class="line"></span><br><span class="line">function sendData() &#123;</span><br><span class="line">  eventBus.emit(&quot;customEvent&quot;, &quot;Hello from A&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;button @click=&quot;sendData&quot;&gt;发送数据&lt;/button&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">// 组件B （接收数据）</span><br><span class="line">&lt;script setup&gt;</span><br><span class="line">import &#123; onMounted &#125; from &quot;vue&quot;;</span><br><span class="line">import &#123; eventBus &#125; from &quot;@/eventBus.js&quot;;</span><br><span class="line"></span><br><span class="line">onMounted(() =&gt; &#123;</span><br><span class="line">  eventBus.on(&quot;customEvent&quot;, (data) =&gt; &#123;</span><br><span class="line">    console.log(&quot;组件 B 收到：&quot;, data);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>reactive 和 ref 的区别？</p>
<ul>
<li>reactive() 用于对象，内部用 Proxy 实现，ref() 用于基本类型，需要 .value</li>
</ul>
</li>
<li><p>ref 为什么可以用在对象上？</p>
<ul>
<li>Vue3 允许 ref 也能包裹对象，但会自动 转换成 reactive</li>
</ul>
</li>
<li><p>vue3 生命周期</p>
<ul>
<li>beforeCreate -&gt; setup() -&gt; onBeforeMount -&gt; onMounted<br>-&gt; onBeforeUpdate -&gt; onUpdated<br>-&gt; onBeforeUnmount -&gt; onUnmounted</li>
</ul>
</li>
<li><p>setup() 和 mounted() 的区别？</p>
<ul>
<li>setup() 在 组件创建前 beforCreate 执行，不能访问 DOM。</li>
<li>mounted() 在 DOM 挂载后 执行，适合操作 DOM</li>
</ul>
</li>
<li><p>toRef 和 toRefs 是干嘛的？</p>
<ul>
<li>toRef(obj, ‘key’)：创建单个 ref</li>
<li>toRefs(obj)：把整个 reactive 转换成 ref 组成的对象</li>
</ul>
</li>
<li><p>shallowRef 和 shallowReactive 区别？</p>
<ul>
<li>shallowRef() 只让 最外层响应式，内部不监听</li>
<li>shallowReactive() 只让 第一层响应式，深层对象不会变。</li>
</ul>
</li>
</ul>
<h3 id="TypeScript"><a href="#TypeScript" class="headerlink" title="TypeScript"></a>TypeScript</h3><h4 id="Typescript-是什么-请简述"><a href="#Typescript-是什么-请简述" class="headerlink" title="Typescript 是什么 请简述?"></a>Typescript 是什么 请简述?</h4><ul>
<li>javascript 的强类型版本超集</li>
</ul>
<h4 id="Typescript-与-javascript-的优势"><a href="#Typescript-与-javascript-的优势" class="headerlink" title="Typescript 与 javascript 的优势?"></a>Typescript 与 javascript 的优势?</h4><ul>
<li>Typescript 优势<ol>
<li>能帮助开发人员检测出错误并修改</li>
<li>TypeScript 工具使重构更变的容易、快捷</li>
<li>类型安全能在编码期间检测错误,可以更好的协作,对于大型项目更友好</li>
<li>便于开发人员做注释</li>
</ol>
</li>
<li>javascript 优势<ol>
<li>不需要编译,直接由浏览器执行</li>
<li>社区成熟,可以很方便地找到大量成熟的开发项目和可用资源</li>
<li>比较灵活</li>
</ol>
</li>
</ul>
<h3 id="工程化工具"><a href="#工程化工具" class="headerlink" title="工程化工具"></a>工程化工具</h3><h4 id="Webpack"><a href="#Webpack" class="headerlink" title="Webpack"></a>Webpack</h4><ul>
<li>Webpack 与 gulp 区别<ul>
<li>Webpack 和另外两个并没有太多的可比性,Gulp&#x2F;Grunt 是一种能够优化前端的开发流程的工具,而 WebPack 是一种模块化的解决方案,不过 Webpack 的优点使得 Webpack 在很多场景下可以替代 Gulp&#x2F;Grunt 类的工具.</li>
</ul>
</li>
<li>请简述 webpack 中的 loaders 与 plugin 的区别<ul>
<li>loader:模块转换器(翻译器),如 less –&gt; css, 如识别 js 结尾的,css 结尾的,图片格式结尾的,通过 loader 转换成相应的文件格式</li>
<li>plugin:扩展插件,如 HtmlWebpackPlugin</li>
</ul>
</li>
<li>说一下 webpack 的打包原理<ul>
<li>把所有依赖打包成一个 bundle.js 文件,通过代码分割成单元片段并按需加载.</li>
</ul>
</li>
<li>说一下对 websocket 的理解<ul>
<li>WebSocket 是 html5 出的一个持久化的协议,它是 HTTP 协议上的一种补充,因为 HTTP 协议通信只能由客户端发起,如果要获取一些实时性较高的信息,只能通过“轮询”一类的方式,但是要不停连接所以轮询的效率低,非常浪费资源.所以通过 websocket 协议可以让服务器主动向客户端推送消息解决了这种问题,做到双向平等对话</li>
</ul>
</li>
</ul>
<h4 id="Vite"><a href="#Vite" class="headerlink" title="Vite"></a>Vite</h4><ul>
<li>esbuild</li>
</ul>
<h4 id="rollup"><a href="#rollup" class="headerlink" title="rollup"></a>rollup</h4><h4 id="babelrc"><a href="#babelrc" class="headerlink" title="babelrc"></a>babelrc</h4><h4 id="eslint"><a href="#eslint" class="headerlink" title="eslint"></a>eslint</h4><h3 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h3><h4 id="Get-和-post-有什么区别？"><a href="#Get-和-post-有什么区别？" class="headerlink" title="Get 和 post 有什么区别？"></a>Get 和 post 有什么区别？</h4><ol>
<li>get 安全性低,post 有加密所有安全性高</li>
<li>get 发送的数据会暴露在地址栏并且会被保存在历史记录里,而 post 不会</li>
<li>get 参数通过 URL 传递,post 放在 Request body 中.</li>
<li>传输的数据量不同,get 传输的量小,不能大于 2kb,post 理论上没有限制</li>
<li>get 一般用于获取数据,post 一般用于发送数据</li>
</ol>
<h4 id="常见的-HTTP-状态码"><a href="#常见的-HTTP-状态码" class="headerlink" title="常见的 HTTP 状态码:"></a>常见的 HTTP 状态码:</h4><ul>
<li>1##:信息响应类,表示接收到请求并且继续处理<ul>
<li>100 继续.客户端应继续其请求</li>
</ul>
</li>
<li>2##:处理成功响应类,表示动作被成功接收、理解和接受<ul>
<li>200 正常返回数据</li>
</ul>
</li>
<li>3##:重定向响应类,为了完成指定的动作,必须接受进一步处理<ul>
<li>301 Moved Permanently 永久性转移&#x2F;重定向</li>
<li>302 Move Temporarily 临时转移</li>
<li>307 Temporary Redirect 临时重定向,一般应用于服务器的负载均衡</li>
<li>304 Not Modified ——客户端已经执行了 GET,但文件未变化</li>
</ul>
</li>
<li>4##:客户端错误,客户请求包含语法错误或者是不能正确执行<ul>
<li>400 Bad Request 请求参数错误</li>
<li>401 Unauthorized 无权限访问</li>
<li>404 Not Found 地址错误</li>
<li>405 Method Not Allowed 当前请求的方式服务器不支持</li>
</ul>
</li>
<li>5##:服务端错误,服务器不能正确执行一个正确的请求<ul>
<li>500 Internal Server Error 未知服务器错误</li>
<li>503 Service Unavailable 服务器超负荷</li>
</ul>
</li>
</ul>
<h4 id="http-是什么-有什么特点"><a href="#http-是什么-有什么特点" class="headerlink" title="http 是什么?有什么特点"></a>http 是什么?有什么特点</h4><ul>
<li>http 是客户端浏览器或其他程序与 Web 服务器之间的应用层通信协议</li>
<li>特点:<ol>
<li>简单快速灵活:客户向服务器请求服务时,只需传送请求方法和路径且 HTTP 允许传输任意类型的数据对象</li>
<li>无连接:每次连接只处理一个请求,收到用户应答后,就断开连接</li>
<li>无状态:协议对于事务处理没有记忆能力,如果后续处理需要前面的信息,则它必须重传</li>
</ol>
</li>
</ul>
<h4 id="HTTP-协议和-HTTPS-区别"><a href="#HTTP-协议和-HTTPS-区别" class="headerlink" title="HTTP 协议和 HTTPS 区别"></a>HTTP 协议和 HTTPS 区别</h4><ol>
<li>传输信息安全性不同;前者是超文本传输协议,信息是明文传输,后者是具有安全性的 ssl 加密传输协议</li>
<li>连接方式不同:前者很简单是无状态的,后者是由 SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议</li>
<li>端口不同:前者端口是 80,后者是 443</li>
</ol>
<h4 id="什么是-csrf-攻击"><a href="#什么是-csrf-攻击" class="headerlink" title="什么是 csrf 攻击"></a>什么是 csrf 攻击</h4><ul>
<li>csrf(cross-site request forgery)是跨站请求伪造;攻击者盗用了用户的身份,以用户的名义发送恶意请求,它可以做的事情包括 以用户的名义发邮件,发消息,购买物品和盗取用户账户</li>
</ul>
<h4 id="为什么会造成跨域-请简述同源策略"><a href="#为什么会造成跨域-请简述同源策略" class="headerlink" title="为什么会造成跨域&#x2F;请简述同源策略"></a>为什么会造成跨域&#x2F;请简述同源策略</h4><ul>
<li>不符合同源协议(不同协议;不同域名&#x2F;IP;不同端口号),</li>
<li>解决方法:<ol>
<li>JSONP 请求:JSONP 的原理是利用 script 标签的跨域特性,可以不受限制地从其他域中加载资源</li>
<li>CORS 跨域:就是使用自定义的 HTTP 头部让浏览器与服务器进行沟通,从而决定请求或响应是应该成功还是应该失败.</li>
<li>Web sockets 跨域:是 HTML5 一种新的协议.它实现了浏览器与服务器全双工通信,同时允许跨域通讯,在 js 中创建 WebSockets 后,会有一个 HTTP 请求发送到浏览器以发起连接.在取得服务器响应后,建立的连接会使用 HTTP 升级从 HTTP 协议交换为 WebSocket 协议,所以只能支持此协议的专门服务器才能正常工作</li>
<li>proxy 代理:请求不会直接发给目标主机,而是先发给代理机再向目标主机发送,接收目标机数据后再由代理服务器返还给用户</li>
</ol>
</li>
</ul>
<h4 id="什么是-CORS"><a href="#什么是-CORS" class="headerlink" title="什么是 CORS"></a>什么是 CORS</h4><ul>
<li>CORS 是一个 W3C 标准,全称是”跨域资源共享”(Cross-Origin Resource Sharing).它允许浏览器向跨源服务器,发出 XMLHttpRequest 请求,从而克服了 ajax 只能同源使用的限制.</li>
</ul>
<h4 id="后台传递过来的数据格式有哪些"><a href="#后台传递过来的数据格式有哪些" class="headerlink" title="后台传递过来的数据格式有哪些"></a>后台传递过来的数据格式有哪些</h4><ol>
<li>json:一段用数组或对象表示得键值对</li>
<li>arraybuffer: 通用的、固定长度的原始二进制数据缓冲区,它是一个字节数组</li>
<li>blob : 一个不可变、原始数据的类文件对象.它的数据可以按文本或二进制的格式进行读取</li>
<li>document : 如 xml 一类的文件格式</li>
<li>text : 文本格式</li>
<li>stream : 数据流</li>
</ol>
<h3 id="算法题"><a href="#算法题" class="headerlink" title="算法题"></a>算法题</h3><h4 id="数组去重的方式"><a href="#数组去重的方式" class="headerlink" title="数组去重的方式"></a>数组去重的方式</h4><ol>
<li>双层 for 循环</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">unique</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = i + <span class="number">1</span>; j &lt; arr.<span class="property">length</span>; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (arr[i] == arr[j]) &#123;</span><br><span class="line">        <span class="comment">//第一个等同于第二个,splice方法删除第二个</span></span><br><span class="line">        arr.<span class="title function_">splice</span>(j, <span class="number">1</span>);</span><br><span class="line">        j--; <span class="comment">//删除后需要让j的位置回退一个,不然会跳过一个数</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>利用 indexOf 去重</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">unique</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> array = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (array.<span class="title function_">indexOf</span>(arr[i]) === -<span class="number">1</span>) &#123;</span><br><span class="line">      array.<span class="title function_">push</span>(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>利用 filter 过滤</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">unique</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> arr.<span class="title function_">filter</span>(<span class="keyword">function</span> (<span class="params">item, index, arr</span>) &#123;</span><br><span class="line">    <span class="comment">//如果当前元素在原始数组的第一个索引==当前循环索引,返回当前元素,不然就过滤掉</span></span><br><span class="line">    <span class="keyword">return</span> arr.<span class="title function_">indexOf</span>(item, <span class="number">0</span>) === index;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>利用 ES6 Set 去重</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">unique</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Array</span>.<span class="title function_">from</span>(<span class="keyword">new</span> <span class="title class_">Set</span>(arr));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="数组排序的方式"><a href="#数组排序的方式" class="headerlink" title="数组排序的方式"></a>数组排序的方式</h4><ol>
<li><p>冒泡排序</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sort</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> temp = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.<span class="property">length</span> - <span class="number">1</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; arr.<span class="property">length</span> - i - <span class="number">1</span>; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">        temp = arr[j];</span><br><span class="line">        arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">        arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><a href="/img/posts/240401/1.awebp" class="gallery-item" style="box-shadow: none;"> <img src="/img/posts/240401/1.awebp" style="min-width:200px"/></a></li>
<li><a target="_blank" rel="noopener" href="https://www.yuque.com/kanding/ktech/bmy2w1i1s4fo6k9w">https://www.yuque.com/kanding/ktech/bmy2w1i1s4fo6k9w</a></li>
</ul>
</li>
<li><p>擂台排序</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sort</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> temp = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.<span class="property">length</span> - <span class="number">1</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = i + <span class="number">1</span>; j &lt; arr.<span class="property">length</span>; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (arr[i] &gt; arr[j]) &#123;</span><br><span class="line">        temp = arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = temp;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>sort 排序</p>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sort</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">  arr.<span class="title function_">sort</span>(<span class="function">(<span class="params">small, big</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> small - big;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="遍历一个多维数组"><a href="#遍历一个多维数组" class="headerlink" title="遍历一个多维数组"></a>遍历一个多维数组</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">each</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">    <span class="keyword">typeof</span> obj[key] == <span class="string">&quot;object&quot;</span></span><br><span class="line">      ? <span class="title function_">each</span>(obj[key])</span><br><span class="line">      : <span class="variable language_">console</span>.<span class="title function_">log</span>(key + <span class="string">&quot;--&quot;</span> + obj[key]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="深拷贝的代码实现"><a href="#深拷贝的代码实现" class="headerlink" title="深拷贝的代码实现"></a>深拷贝的代码实现</h4><ul>
<li>简单深拷贝(一层拷贝)<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">deepCopy</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> copyObj = <span class="title class_">Array</span>.<span class="title function_">isArray</span>(obj) ? [] : &#123;&#125;;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">    copyObj[key] = obj[key];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> copyObj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>复杂深拷贝(递归实现多层拷贝)<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">deepCopy</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> copyObj = <span class="title class_">Array</span>.<span class="title function_">isArray</span>(obj) ? [] : &#123;&#125;;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">    <span class="keyword">if</span> (obj.<span class="title function_">hasOwnProperty</span>(key)) &#123;</span><br><span class="line">      copyObj[key] =</span><br><span class="line">        <span class="keyword">typeof</span> obj[key] === <span class="string">&quot;object&quot;</span> ? <span class="title function_">deepCopy</span>(obj[key]) : obj[key];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> copyObj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="合并两个有序数组"><a href="#合并两个有序数组" class="headerlink" title="合并两个有序数组"></a>合并两个有序数组</h4><blockquote>
<p>给你两个按 非递减顺序 排列的整数数组 nums1 和 nums2，另有两个整数 m 和 n ，分别表示 nums1 和 nums2 中的元素数目。<br>请你 合并 nums2 到 nums1 中，使合并后的数组同样按 非递减顺序 排列。<br>注意：最终，合并后数组不应由函数返回，而是存储在数组 nums1 中。为了应对这种情况，nums1 的初始长度为 m + n，其中前 m 个元素表示应合并的元素，后 n 个元素为 0 ，应忽略。nums2 的长度为 n</p>
</blockquote>
</div><script src="https://jsd.onmicrosoft.cn/npm/hexo-theme-a4@latest/source/js/lightgallery.min.js"></script><script>if("undefined"!=typeof lightGallery) {
        var options1 = {
            selector: '.gallery-item'
        };
        lightGallery(document.getElementsByClassName('.article-gallery')[0], options1);
        }</script>
    </div>

    <div class="post-meta">
        <i>
        
            <span>2024-04-01</span>
            
                <span>该篇文章被 Andrew</span>
            
            
             
                <span>归为分类:
                    
                    
                        <a href='/categories/%E6%8A%80%E6%9C%AF/'>
                            技术
                        </a>
                    
                </span>
            
        
        </i>
    </div>
    <br>
    
    <!-- <div class="post-footer-pre-next">
        <span>上一篇：<a href=""></a></span>
        <span class="post-footer-pre-next-last-span-right">上一篇：<a href=""></a></span>
    </div> -->

    
        

     
</div>



                                      
                    
                    
                    <div class="footer">
    
        <span> 
            © 2023-2024 

            
                

            
        </span>
    
</div>
<!--这是指一条线往下的内容-->
<div class="footer-last">
    
            <span>永远相信美好的事情即将发生</span>
            
                <span class="footer-last-span-right"><i>本站由<a target="_blank" rel="noopener" href="https://hexo.io/zh-cn/index.html">Hexo</a>驱动｜使用<a target="_blank" rel="noopener" href="https://github.com/HiNinoJay/hexo-theme-A4">Hexo-theme-A4</a>主题</i></span>
            
    
</div>


    
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.0/jquery.min.js"></script>

    <!--目录-->
    
        <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/1.7.2/jquery.min.js" type="text/javascript" ></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/jqueryui/1.12.1/jquery-ui.min.js" type="text/javascript" ></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery.tocify/1.9.0/javascripts/jquery.tocify.min.js" type="text/javascript" ></script>
        
<script src="/js/toc.js"></script>

    

    
<script src="/js/randomHeaderContent.js"></script>

    <!--回到顶部按钮-->
    
        
<script src="/js/returnToTop.js"></script>

    

    
        
<script src="/js/returnToLastPage.js"></script>

    





<script src="/js/lightgallery.min.js"></script>



                </div>
            
            
                <!-- 回到顶部的按钮-->  
                <div class="progress-wrap shadow-drop-2-bottom">
                    <svg class="progress-circle svg-content" width="100%" height="100%" viewBox="-1 -1 102 102">
                        <path d="M50,1 a49,49 0 0,1 0,98 a49,49 0 0,1 0,-98"/>
                    </svg>
                </div>
            
            
                <!-- 返回的按钮-->  
                <div class="return-to-last-progress-wrap shadow-drop-2-bottom">
                    <svg class="progress-circle svg-content" width="100%" height="100%" viewBox="-1 -1 102 102">
                        <path d="M50,1 a49,49 0 0,1 0,98 a49,49 0 0,1 0,-98"/>
                    </svg>
                </div>
            
    </body>
</html>